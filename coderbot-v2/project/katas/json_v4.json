{
  "title": "V4",
  "content": "NewInMemoryPlayerStore initialises an empty player store.",
  "correct_code": "package main\n\n// NewInMemoryPlayerStore initialises an empty player store.\nfunc NewInMemoryPlayerStore() *InMemoryPlayerStore {\n\treturn &InMemoryPlayerStore{map[string]int{}}\n}\n\n// InMemoryPlayerStore collects data about players in memory.\ntype InMemoryPlayerStore struct {\n\tstore map[string]int\n}\n\n// GetLeague currently doesn't work, but it should return the player league.\nfunc (i *InMemoryPlayerStore) GetLeague() []Player {\n\treturn nil\n}\n\n// RecordWin will record a player's win.\nfunc (i *InMemoryPlayerStore) RecordWin(name string) {\n\ti.store[name]++\n}\n\n// GetPlayerScore retrieves scores for a given player.\nfunc (i *InMemoryPlayerStore) GetPlayerScore(name string) int {\n\treturn i.store[name]\n}\n\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tserver := NewPlayerServer(NewInMemoryPlayerStore())\n\tlog.Fatal(http.ListenAndServe(\":5000\", server))\n}\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// PlayerStore stores score information about players.\ntype PlayerStore interface {\n\tGetPlayerScore(name string) int\n\tRecordWin(name string)\n\tGetLeague() []Player\n}\n\n// Player stores a name with a number of wins.\ntype Player struct {\n\tName string\n\tWins int\n}\n\n// PlayerServer is a HTTP interface for player information.\ntype PlayerServer struct {\n\tstore PlayerStore\n\thttp.Handler\n}\n\n// NewPlayerServer creates a PlayerServer with routing configured.\nfunc NewPlayerServer(store PlayerStore) *PlayerServer {\n\tp := new(PlayerServer)\n\n\tp.store = store\n\n\trouter := http.NewServeMux()\n\trouter.Handle(\"/league\", http.HandlerFunc(p.leagueHandler))\n\trouter.Handle(\"/players/\", http.HandlerFunc(p.playersHandler))\n\n\tp.Handler = router\n\n\treturn p\n}\n\nfunc (p *PlayerServer) leagueHandler(w http.ResponseWriter, r *http.Request) {\n\tjson.NewEncoder(w).Encode(p.store.GetLeague())\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc (p *PlayerServer) playersHandler(w http.ResponseWriter, r *http.Request) {\n\tplayer := strings.TrimPrefix(r.URL.Path, \"/players/\")\n\n\tswitch r.Method {\n\tcase http.MethodPost:\n\t\tp.processWin(w, player)\n\tcase http.MethodGet:\n\t\tp.showScore(w, player)\n\t}\n}\n\nfunc (p *PlayerServer) showScore(w http.ResponseWriter, player string) {\n\tscore := p.store.GetPlayerScore(player)\n\n\tif score == 0 {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t}\n\n\tfmt.Fprint(w, score)\n}\n\nfunc (p *PlayerServer) processWin(w http.ResponseWriter, player string) {\n\tp.store.RecordWin(player)\n\tw.WriteHeader(http.StatusAccepted)\n}",
  "test_code": "package main\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc TestRecordingWinsAndRetrievingThem(t *testing.T) {\n\tstore := NewInMemoryPlayerStore()\n\tserver := NewPlayerServer(store)\n\tplayer := \"Pepper\"\n\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\n\tresponse := httptest.NewRecorder()\n\tserver.ServeHTTP(response, newGetScoreRequest(player))\n\tassertStatus(t, response.Code, http.StatusOK)\n\n\tassertResponseBody(t, response.Body.String(), \"3\")\n}\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype StubPlayerStore struct {\n\tscores   map[string]int\n\twinCalls []string\n\tleague   []Player\n}\n\nfunc (s *StubPlayerStore) GetPlayerScore(name string) int {\n\tscore := s.scores[name]\n\treturn score\n}\n\nfunc (s *StubPlayerStore) RecordWin(name string) {\n\ts.winCalls = append(s.winCalls, name)\n}\n\nfunc (s *StubPlayerStore) GetLeague() []Player {\n\treturn s.league\n}\n\nfunc TestGETPlayers(t *testing.T) {\n\tstore := StubPlayerStore{\n\t\tmap[string]int{\n\t\t\t\"Pepper\": 20,\n\t\t\t\"Floyd\":  10,\n\t\t},\n\t\tnil,\n\t\tnil,\n\t}\n\tserver := NewPlayerServer(&store)\n\n\tt.Run(\"returns Pepper's score\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Pepper\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\t\tassertResponseBody(t, response.Body.String(), \"20\")\n\t})\n\n\tt.Run(\"returns Floyd's score\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Floyd\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\t\tassertResponseBody(t, response.Body.String(), \"10\")\n\t})\n\n\tt.Run(\"returns 404 on missing players\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Apollo\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusNotFound)\n\t})\n}\n\nfunc TestStoreWins(t *testing.T) {\n\tstore := StubPlayerStore{\n\t\tmap[string]int{},\n\t\tnil,\n\t\tnil,\n\t}\n\tserver := NewPlayerServer(&store)\n\n\tt.Run(\"it records wins on POST\", func(t *testing.T) {\n\t\tplayer := \"Pepper\"\n\n\t\trequest := newPostWinRequest(player)\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusAccepted)\n\n\t\tif len(store.winCalls) != 1 {\n\t\t\tt.Fatalf(\"got %d calls to RecordWin want %d\", len(store.winCalls), 1)\n\t\t}\n\n\t\tif store.winCalls[0] != player {\n\t\t\tt.Errorf(\"did not store correct winner got %q want %q\", store.winCalls[0], player)\n\t\t}\n\t})\n}\n\nfunc TestLeague(t *testing.T) {\n\n\tt.Run(\"it returns the league table as JSON\", func(t *testing.T) {\n\t\twantedLeague := []Player{\n\t\t\t{\"Cleo\", 32},\n\t\t\t{\"Chris\", 20},\n\t\t\t{\"Tiest\", 14},\n\t\t}\n\n\t\tstore := StubPlayerStore{nil, nil, wantedLeague}\n\t\tserver := NewPlayerServer(&store)\n\n\t\trequest := newLeagueRequest()\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tgot := getLeagueFromResponse(t, response.Body)\n\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\t\tassertLeague(t, got, wantedLeague)\n\t})\n}\n\nfunc getLeagueFromResponse(t testing.TB, body io.Reader) (league []Player) {\n\tt.Helper()\n\terr := json.NewDecoder(body).Decode(&league)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to parse response from server %q into slice of Player, '%v'\", body, err)\n\t}\n\n\treturn\n}\n\nfunc assertLeague(t testing.TB, got, want []Player) {\n\tt.Helper()\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\nfunc assertStatus(t testing.TB, got, want int) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"did not get correct status, got %d, want %d\", got, want)\n\t}\n}\n\nfunc newLeagueRequest() *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, \"/league\", nil)\n\treturn req\n}\n\nfunc newGetScoreRequest(name string) *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, fmt.Sprintf(\"/players/%s\", name), nil)\n\treturn req\n}\n\nfunc newPostWinRequest(name string) *http.Request {\n\treq, _ := http.NewRequest(http.MethodPost, fmt.Sprintf(\"/players/%s\", name), nil)\n\treturn req\n}\n\nfunc assertResponseBody(t testing.TB, got, want string) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"response body is wrong, got %q want %q\", got, want)\n\t}\n}",
  "difficulty": "Intermedi√°rio"
}
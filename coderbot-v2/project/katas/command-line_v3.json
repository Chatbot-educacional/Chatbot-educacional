{
  "title": "V3",
  "content": "CLI helps players through a game of poker.",
  "correct_code": "package poker\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"strings\"\n)\n\n// CLI helps players through a game of poker.\ntype CLI struct {\n\tplayerStore PlayerStore\n\tin          *bufio.Scanner\n}\n\n// NewCLI creates a CLI for playing poker.\nfunc NewCLI(store PlayerStore, in io.Reader) *CLI {\n\treturn &CLI{\n\t\tplayerStore: store,\n\t\tin:          bufio.NewScanner(in),\n\t}\n}\n\n// PlayPoker starts the game.\nfunc (cli *CLI) PlayPoker() {\n\tuserInput := cli.readLine()\n\tcli.playerStore.RecordWin(extractWinner(userInput))\n}\n\nfunc extractWinner(userInput string) string {\n\treturn strings.Replace(userInput, \" wins\", \"\", 1)\n}\n\nfunc (cli *CLI) readLine() string {\n\tcli.in.Scan()\n\treturn cli.in.Text()\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sort\"\n)\n\n// FileSystemPlayerStore stores players in the filesystem.\ntype FileSystemPlayerStore struct {\n\tdatabase *json.Encoder\n\tleague   League\n}\n\n// NewFileSystemPlayerStore creates a FileSystemPlayerStore initialising the store if needed.\nfunc NewFileSystemPlayerStore(file *os.File) (*FileSystemPlayerStore, error) {\n\n\terr := initialisePlayerDBFile(file)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"problem initialising player db file, %v\", err)\n\t}\n\n\tleague, err := NewLeague(file)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"problem loading player store from file %s, %v\", file.Name(), err)\n\t}\n\n\treturn &FileSystemPlayerStore{\n\t\tdatabase: json.NewEncoder(&tape{file}),\n\t\tleague:   league,\n\t}, nil\n}\n\n// FileSystemPlayerStoreFromFile creates a PlayerStore from the contents of a JSON file found at path.\nfunc FileSystemPlayerStoreFromFile(path string) (*FileSystemPlayerStore, func(), error) {\n\tdb, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE, 0666)\n\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"problem opening %s, %v\", path, err)\n\t}\n\n\tcloseFunc := func() {\n\t\tdb.Close()\n\t}\n\n\tstore, err := NewFileSystemPlayerStore(db)\n\n\tif err != nil {\n\t\tdb.Close()\n\t\treturn nil, nil, fmt.Errorf(\"problem creating file system player store, %v \", err)\n\t}\n\n\treturn store, closeFunc, nil\n}\n\nfunc initialisePlayerDBFile(file *os.File) error {\n\tfile.Seek(0, io.SeekStart)\n\n\tinfo, err := file.Stat()\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"problem getting file info from file %s, %v\", file.Name(), err)\n\t}\n\n\tif info.Size() == 0 {\n\t\tfile.Write([]byte(\"[]\"))\n\t\tfile.Seek(0, io.SeekStart)\n\t}\n\n\treturn nil\n}\n\n// GetLeague returns the scores of all the players.\nfunc (f *FileSystemPlayerStore) GetLeague() League {\n\tsort.Slice(f.league, func(i, j int) bool {\n\t\treturn f.league[i].Wins > f.league[j].Wins\n\t})\n\treturn f.league\n}\n\n// GetPlayerScore retrieves a player's score.\nfunc (f *FileSystemPlayerStore) GetPlayerScore(name string) int {\n\n\tplayer := f.league.Find(name)\n\n\tif player != nil {\n\t\treturn player.Wins\n\t}\n\n\treturn 0\n}\n\n// RecordWin will store a win for a player, incrementing wins if already known.\nfunc (f *FileSystemPlayerStore) RecordWin(name string) {\n\tplayer := f.league.Find(name)\n\n\tif player != nil {\n\t\tplayer.Wins++\n\t} else {\n\t\tf.league = append(f.league, Player{name, 1})\n\t}\n\n\tf.database.Encode(f.league)\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n)\n\n// League stores a collection of players.\ntype League []Player\n\n// Find tries to return a player from a league.\nfunc (l League) Find(name string) *Player {\n\tfor i, p := range l {\n\t\tif p.Name == name {\n\t\t\treturn &l[i]\n\t\t}\n\t}\n\treturn nil\n}\n\n// NewLeague creates a league from JSON.\nfunc NewLeague(rdr io.Reader) (League, error) {\n\tvar league []Player\n\terr := json.NewDecoder(rdr).Decode(&league)\n\n\tif err != nil {\n\t\terr = fmt.Errorf(\"problem parsing league, %v\", err)\n\t}\n\n\treturn league, err\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// PlayerStore stores score information about players.\ntype PlayerStore interface {\n\tGetPlayerScore(name string) int\n\tRecordWin(name string)\n\tGetLeague() League\n}\n\n// Player stores a name with a number of wins.\ntype Player struct {\n\tName string\n\tWins int\n}\n\n// PlayerServer is a HTTP interface for player information.\ntype PlayerServer struct {\n\tstore PlayerStore\n\thttp.Handler\n}\n\nconst jsonContentType = \"application/json\"\n\n// NewPlayerServer creates a PlayerServer with routing configured.\nfunc NewPlayerServer(store PlayerStore) *PlayerServer {\n\tp := new(PlayerServer)\n\n\tp.store = store\n\n\trouter := http.NewServeMux()\n\trouter.Handle(\"/league\", http.HandlerFunc(p.leagueHandler))\n\trouter.Handle(\"/players/\", http.HandlerFunc(p.playersHandler))\n\n\tp.Handler = router\n\n\treturn p\n}\n\nfunc (p *PlayerServer) leagueHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", jsonContentType)\n\tjson.NewEncoder(w).Encode(p.store.GetLeague())\n}\n\nfunc (p *PlayerServer) playersHandler(w http.ResponseWriter, r *http.Request) {\n\tplayer := strings.TrimPrefix(r.URL.Path, \"/players/\")\n\n\tswitch r.Method {\n\tcase http.MethodPost:\n\t\tp.processWin(w, player)\n\tcase http.MethodGet:\n\t\tp.showScore(w, player)\n\t}\n}\n\nfunc (p *PlayerServer) showScore(w http.ResponseWriter, player string) {\n\tscore := p.store.GetPlayerScore(player)\n\n\tif score == 0 {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t}\n\n\tfmt.Fprint(w, score)\n}\n\nfunc (p *PlayerServer) processWin(w http.ResponseWriter, player string) {\n\tp.store.RecordWin(player)\n\tw.WriteHeader(http.StatusAccepted)\n}\n\npackage poker\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\ntype tape struct {\n\tfile *os.File\n}\n\nfunc (t *tape) Write(p []byte) (n int, err error) {\n\tt.file.Truncate(0)\n\tt.file.Seek(0, io.SeekStart)\n\treturn t.file.Write(p)\n}\n\npackage poker\n\nimport \"testing\"\n\n// StubPlayerStore implements PlayerStore for testing purposes.\ntype StubPlayerStore struct {\n\tScores   map[string]int\n\tWinCalls []string\n\tLeague   []Player\n}\n\n// GetPlayerScore returns a score from Scores.\nfunc (s *StubPlayerStore) GetPlayerScore(name string) int {\n\tscore := s.Scores[name]\n\treturn score\n}\n\n// RecordWin will record a win to WinCalls.\nfunc (s *StubPlayerStore) RecordWin(name string) {\n\ts.WinCalls = append(s.WinCalls, name)\n}\n\n// GetLeague returns League.\nfunc (s *StubPlayerStore) GetLeague() League {\n\treturn s.League\n}\n\n// AssertPlayerWin allows you to spy on the store's calls to RecordWin.\nfunc AssertPlayerWin(t testing.TB, store *StubPlayerStore, winner string) {\n\tt.Helper()\n\n\tif len(store.WinCalls) != 1 {\n\t\tt.Fatalf(\"got %d calls to RecordWin want %d\", len(store.WinCalls), 1)\n\t}\n\n\tif store.WinCalls[0] != winner {\n\t\tt.Errorf(\"did not store the correct winner got %q want %q\", store.WinCalls[0], winner)\n\t}\n}",
  "test_code": "package poker_test\n\nimport (\n\t\"github.com/quii/learn-go-with-tests/command-line/v3\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestCLI(t *testing.T) {\n\n\tt.Run(\"record chris win from user input\", func(t *testing.T) {\n\t\tin := strings.NewReader(\"Chris wins\\n\")\n\t\tplayerStore := &poker.StubPlayerStore{}\n\n\t\tcli := poker.NewCLI(playerStore, in)\n\t\tcli.PlayPoker()\n\n\t\tpoker.AssertPlayerWin(t, playerStore, \"Chris\")\n\t})\n\n\tt.Run(\"record cleo win from user input\", func(t *testing.T) {\n\t\tin := strings.NewReader(\"Cleo wins\\n\")\n\t\tplayerStore := &poker.StubPlayerStore{}\n\n\t\tcli := poker.NewCLI(playerStore, in)\n\t\tcli.PlayPoker()\n\n\t\tpoker.AssertPlayerWin(t, playerStore, \"Cleo\")\n\t})\n\n\tt.Run(\"do not read beyond the first newline\", func(t *testing.T) {\n\t\tin := failOnEndReader{\n\t\t\tt,\n\t\t\tstrings.NewReader(\"Chris wins\\n hello there\"),\n\t\t}\n\n\t\tplayerStore := &poker.StubPlayerStore{}\n\n\t\tcli := poker.NewCLI(playerStore, in)\n\t\tcli.PlayPoker()\n\t})\n\n}\n\ntype failOnEndReader struct {\n\tt   *testing.T\n\trdr io.Reader\n}\n\nfunc (m failOnEndReader) Read(p []byte) (n int, err error) {\n\n\tn, err = m.rdr.Read(p)\n\n\tif n == 0 || err == io.EOF {\n\t\tm.t.Fatal(\"Read to the end when you shouldn't have\")\n\t}\n\n\treturn n, err\n}\n\npackage poker\n\nimport (\n\t\"os\"\n\t\"testing\"\n)\n\nfunc createTempFile(t testing.TB, initialData string) (*os.File, func()) {\n\tt.Helper()\n\n\ttmpfile, err := os.CreateTemp(\"\", \"db\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"could not create temp file %v\", err)\n\t}\n\n\ttmpfile.Write([]byte(initialData))\n\n\tremoveFile := func() {\n\t\tos.Remove(tmpfile.Name())\n\t}\n\n\treturn tmpfile, removeFile\n}\n\nfunc TestFileSystemStore(t *testing.T) {\n\n\tt.Run(\"league sorted\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tgot := store.GetLeague()\n\n\t\twant := []Player{\n\t\t\t{\"Chris\", 33},\n\t\t\t{\"Cleo\", 10},\n\t\t}\n\n\t\tassertLeague(t, got, want)\n\n\t\t// read again\n\t\tgot = store.GetLeague()\n\t\tassertLeague(t, got, want)\n\t})\n\n\tt.Run(\"get player score\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tgot := store.GetPlayerScore(\"Chris\")\n\t\twant := 33\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"store wins for existing players\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tstore.RecordWin(\"Chris\")\n\n\t\tgot := store.GetPlayerScore(\"Chris\")\n\t\twant := 34\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"store wins for existing players\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tstore.RecordWin(\"Pepper\")\n\n\t\tgot := store.GetPlayerScore(\"Pepper\")\n\t\twant := 1\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"works with an empty file\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, \"\")\n\t\tdefer cleanDatabase()\n\n\t\t_, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\t})\n}\n\nfunc assertScoreEquals(t testing.TB, got, want int) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"got %d want %d\", got, want)\n\t}\n}\n\nfunc assertNoError(t testing.TB, err error) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatalf(\"didn't expect an error but got one, %v\", err)\n\t}\n}\n\npackage poker\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc TestRecordingWinsAndRetrievingThem(t *testing.T) {\n\tdatabase, cleanDatabase := createTempFile(t, `[]`)\n\tdefer cleanDatabase()\n\tstore, err := NewFileSystemPlayerStore(database)\n\n\tassertNoError(t, err)\n\n\tserver := NewPlayerServer(store)\n\tplayer := \"Pepper\"\n\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\n\tt.Run(\"get score\", func(t *testing.T) {\n\t\tresponse := httptest.NewRecorder()\n\t\tserver.ServeHTTP(response, newGetScoreRequest(player))\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\n\t\tassertResponseBody(t, response.Body.String(), \"3\")\n\t})\n\n\tt.Run(\"get league\", func(t *testing.T) {\n\t\tresponse := httptest.NewRecorder()\n\t\tserver.ServeHTTP(response, newLeagueRequest())\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\n\t\tgot := getLeagueFromResponse(t, response.Body)\n\t\twant := []Player{\n\t\t\t{\"Pepper\", 3},\n\t\t}\n\t\tassertLeague(t, got, want)\n\t})\n}\n\npackage poker\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGETPlayers(t *testing.T) {\n\tstore := StubPlayerStore{\n\t\tmap[string]int{\n\t\t\t\"Pepper\": 20,\n\t\t\t\"Floyd\":  10,\n\t\t},\n\t\tnil,\n\t\tnil,\n\t}\n\tserver := NewPlayerServer(&store)\n\n\tt.Run(\"returns Pepper's score\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Pepper\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\t\tassertResponseBody(t, response.Body.String(), \"20\")\n\t})\n\n\tt.Run(\"returns Floyd's score\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Floyd\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\t\tassertResponseBody(t, response.Body.String(), \"10\")\n\t})\n\n\tt.Run(\"returns 404 on missing players\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Apollo\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusNotFound)\n\t})\n}\n\nfunc TestStoreWins(t *testing.T) {\n\tstore := StubPlayerStore{\n\t\tmap[string]int{},\n\t\tnil,\n\t\tnil,\n\t}\n\tserver := NewPlayerServer(&store)\n\n\tt.Run(\"it records wins on POST\", func(t *testing.T) {\n\t\tplayer := \"Pepper\"\n\n\t\trequest := newPostWinRequest(player)\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusAccepted)\n\t\tAssertPlayerWin(t, &store, player)\n\t})\n}\n\nfunc TestLeague(t *testing.T) {\n\n\tt.Run(\"it returns the league table as JSON\", func(t *testing.T) {\n\t\twantedLeague := []Player{\n\t\t\t{\"Cleo\", 32},\n\t\t\t{\"Chris\", 20},\n\t\t\t{\"Tiest\", 14},\n\t\t}\n\n\t\tstore := StubPlayerStore{nil, nil, wantedLeague}\n\t\tserver := NewPlayerServer(&store)\n\n\t\trequest := newLeagueRequest()\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tgot := getLeagueFromResponse(t, response.Body)\n\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\t\tassertLeague(t, got, wantedLeague)\n\t\tassertContentType(t, response, jsonContentType)\n\n\t})\n}\n\nfunc assertContentType(t testing.TB, response *httptest.ResponseRecorder, want string) {\n\tt.Helper()\n\tif response.Header().Get(\"content-type\") != want {\n\t\tt.Errorf(\"response did not have content-type of %s, got %v\", want, response.Result().Header)\n\t}\n}\n\nfunc getLeagueFromResponse(t testing.TB, body io.Reader) []Player {\n\tt.Helper()\n\tleague, err := NewLeague(body)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to parse response from server %q into slice of Player, '%v'\", body, err)\n\t}\n\n\treturn league\n}\n\nfunc assertLeague(t testing.TB, got, want []Player) {\n\tt.Helper()\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\nfunc assertStatus(t testing.TB, got, want int) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"did not get correct status, got %d, want %d\", got, want)\n\t}\n}\n\nfunc newLeagueRequest() *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, \"/league\", nil)\n\treturn req\n}\n\nfunc newGetScoreRequest(name string) *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, fmt.Sprintf(\"/players/%s\", name), nil)\n\treturn req\n}\n\nfunc newPostWinRequest(name string) *http.Request {\n\treq, _ := http.NewRequest(http.MethodPost, fmt.Sprintf(\"/players/%s\", name), nil)\n\treturn req\n}\n\nfunc assertResponseBody(t testing.TB, got, want string) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"response body is wrong, got %q want %q\", got, want)\n\t}\n}\n\npackage poker\n\nimport (\n\t\"io\"\n\t\"testing\"\n)\n\nfunc TestTape_Write(t *testing.T) {\n\tfile, clean := createTempFile(t, \"12345\")\n\tdefer clean()\n\n\ttape := &tape{file}\n\n\ttape.Write([]byte(\"abc\"))\n\n\tfile.Seek(0, io.SeekStart)\n\tnewFileContents, _ := io.ReadAll(file)\n\n\tgot := string(newFileContents)\n\twant := \"abc\"\n\n\tif got != want {\n\t\tt.Errorf(\"got %q want %q\", got, want)\n\t}\n}",
  "difficulty": "Intermedi√°rio"
}
{
  "title": "V10",
  "content": "",
  "correct_code": "package main\n\nimport (\n\t\"reflect\"\n)\n\nfunc walk(x interface{}, fn func(input string)) {\n\tval := getValue(x)\n\n\twalkValue := func(value reflect.Value) {\n\t\twalk(value.Interface(), fn)\n\t}\n\n\tswitch val.Kind() {\n\tcase reflect.String:\n\t\tfn(val.String())\n\tcase reflect.Struct:\n\t\tfor i := 0; i < val.NumField(); i++ {\n\t\t\twalkValue(val.Field(i))\n\t\t}\n\tcase reflect.Slice, reflect.Array:\n\t\tfor i := 0; i < val.Len(); i++ {\n\t\t\twalkValue(val.Index(i))\n\t\t}\n\tcase reflect.Map:\n\t\tfor _, key := range val.MapKeys() {\n\t\t\twalkValue(val.MapIndex(key))\n\t\t}\n\tcase reflect.Chan:\n\t\tfor v, ok := val.Recv(); ok; v, ok = val.Recv() {\n\t\t\twalkValue(v)\n\t\t}\n\tcase reflect.Func:\n\t\tvalFnResult := val.Call(nil)\n\t\tfor _, res := range valFnResult {\n\t\t\twalkValue(res)\n\t\t}\n\t}\n}\n\nfunc getValue(x interface{}) reflect.Value {\n\tval := reflect.ValueOf(x)\n\n\tif val.Kind() == reflect.Ptr {\n\t\tval = val.Elem()\n\t}\n\n\treturn val\n}",
  "test_code": "package main\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestWalk(t *testing.T) {\n\n\tcases := []struct {\n\t\tName          string\n\t\tInput         interface{}\n\t\tExpectedCalls []string\n\t}{\n\t\t{\n\t\t\t\"struct with one string field\",\n\t\t\tstruct{ Name string }{\"Chris\"},\n\t\t\t[]string{\"Chris\"},\n\t\t},\n\t\t{\n\t\t\t\"struct with two string fields\",\n\t\t\tstruct {\n\t\t\t\tName string\n\t\t\t\tCity string\n\t\t\t}{\"Chris\", \"London\"},\n\t\t\t[]string{\"Chris\", \"London\"},\n\t\t},\n\t\t{\n\t\t\t\"struct with non string field\",\n\t\t\tstruct {\n\t\t\t\tName string\n\t\t\t\tAge  int\n\t\t\t}{\"Chris\", 33},\n\t\t\t[]string{\"Chris\"},\n\t\t},\n\t\t{\n\t\t\t\"nested fields\",\n\t\t\tPerson{\n\t\t\t\t\"Chris\",\n\t\t\t\tProfile{33, \"London\"},\n\t\t\t},\n\t\t\t[]string{\"Chris\", \"London\"},\n\t\t},\n\t\t{\n\t\t\t\"pointers to things\",\n\t\t\t&Person{\n\t\t\t\t\"Chris\",\n\t\t\t\tProfile{33, \"London\"},\n\t\t\t},\n\t\t\t[]string{\"Chris\", \"London\"},\n\t\t},\n\t\t{\n\t\t\t\"slices\",\n\t\t\t[]Profile{\n\t\t\t\t{33, \"London\"},\n\t\t\t\t{34, \"Reykjavík\"},\n\t\t\t},\n\t\t\t[]string{\"London\", \"Reykjavík\"},\n\t\t},\n\t\t{\n\t\t\t\"arrays\",\n\t\t\t[2]Profile{\n\t\t\t\t{33, \"London\"},\n\t\t\t\t{34, \"Reykjavík\"},\n\t\t\t},\n\t\t\t[]string{\"London\", \"Reykjavík\"},\n\t\t},\n\t}\n\n\tfor _, test := range cases {\n\t\tt.Run(test.Name, func(t *testing.T) {\n\t\t\tvar got []string\n\t\t\twalk(test.Input, func(input string) {\n\t\t\t\tgot = append(got, input)\n\t\t\t})\n\n\t\t\tif !reflect.DeepEqual(got, test.ExpectedCalls) {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, test.ExpectedCalls)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"with maps\", func(t *testing.T) {\n\t\taMap := map[string]string{\n\t\t\t\"Foo\": \"Bar\",\n\t\t\t\"Baz\": \"Boz\",\n\t\t}\n\n\t\tvar got []string\n\t\twalk(aMap, func(input string) {\n\t\t\tgot = append(got, input)\n\t\t})\n\n\t\tassertContains(t, got, \"Bar\")\n\t\tassertContains(t, got, \"Boz\")\n\t})\n\n\tt.Run(\"with channels\", func(t *testing.T) {\n\t\taChannel := make(chan Profile)\n\n\t\tgo func() {\n\t\t\taChannel <- Profile{33, \"Berlin\"}\n\t\t\taChannel <- Profile{34, \"Katowice\"}\n\t\t\tclose(aChannel)\n\t\t}()\n\n\t\tvar got []string\n\t\twant := []string{\"Berlin\", \"Katowice\"}\n\n\t\twalk(aChannel, func(input string) {\n\t\t\tgot = append(got, input)\n\t\t})\n\n\t\tif !reflect.DeepEqual(got, want) {\n\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"with function\", func(t *testing.T) {\n\t\taFunction := func() (Profile, Profile) {\n\t\t\treturn Profile{33, \"Berlin\"}, Profile{34, \"Katowice\"}\n\t\t}\n\n\t\tvar got []string\n\t\twant := []string{\"Berlin\", \"Katowice\"}\n\n\t\twalk(aFunction, func(input string) {\n\t\t\tgot = append(got, input)\n\t\t})\n\n\t\tif !reflect.DeepEqual(got, want) {\n\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t}\n\t})\n}\n\ntype Person struct {\n\tName    string\n\tProfile Profile\n}\n\ntype Profile struct {\n\tAge  int\n\tCity string\n}\n\nfunc assertContains(t testing.TB, haystack []string, needle string) {\n\tt.Helper()\n\tcontains := false\n\tfor _, x := range haystack {\n\t\tif x == needle {\n\t\t\tcontains = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !contains {\n\t\tt.Errorf(\"expected %v to contain %q but it didn't\", haystack, needle)\n\t}\n}",
  "difficulty": "Difícil"
}
{
  "title": "V2",
  "content": "BlindAlerter schedules alerts for blind amounts.",
  "correct_code": "package poker\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n)\n\n// BlindAlerter schedules alerts for blind amounts.\ntype BlindAlerter interface {\n\tScheduleAlertAt(duration time.Duration, amount int, to io.Writer)\n}\n\n// BlindAlerterFunc allows you to implement BlindAlerter with a function.\ntype BlindAlerterFunc func(duration time.Duration, amount int, to io.Writer)\n\n// ScheduleAlertAt is BlindAlerterFunc implementation of BlindAlerter.\nfunc (a BlindAlerterFunc) ScheduleAlertAt(duration time.Duration, amount int, to io.Writer) {\n\ta(duration, amount, to)\n}\n\n// Alerter will schedule alerts and print them to \"to\".\nfunc Alerter(duration time.Duration, amount int, to io.Writer) {\n\ttime.AfterFunc(duration, func() {\n\t\tfmt.Fprintf(to, \"Blind is now %d\\n\", amount)\n\t})\n}\n\npackage poker\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CLI helps players through a game of poker.\ntype CLI struct {\n\tplayerStore PlayerStore\n\tin          *bufio.Scanner\n\tout         io.Writer\n\tgame        Game\n}\n\n// NewCLI creates a CLI for playing poker.\nfunc NewCLI(in io.Reader, out io.Writer, game Game) *CLI {\n\treturn &CLI{\n\t\tin:   bufio.NewScanner(in),\n\t\tout:  out,\n\t\tgame: game,\n\t}\n}\n\n// PlayerPrompt is the text asking the user for the number of players.\nconst PlayerPrompt = \"Please enter the number of players: \"\n\n// BadPlayerInputErrMsg is the text telling the user they did bad things.\nconst BadPlayerInputErrMsg = \"Bad value received for number of players, please try again with a number\"\n\n// BadWinnerInputMsg is the text telling the user they declared the winner wrong.\nconst BadWinnerInputMsg = \"invalid winner input, expect format of 'PlayerName wins'\"\n\n// PlayPoker starts the game.\nfunc (cli *CLI) PlayPoker() {\n\tfmt.Fprint(cli.out, PlayerPrompt)\n\n\tnumberOfPlayers, err := strconv.Atoi(cli.readLine())\n\n\tif err != nil {\n\t\tfmt.Fprint(cli.out, BadPlayerInputErrMsg)\n\t\treturn\n\t}\n\n\tcli.game.Start(numberOfPlayers, cli.out)\n\n\twinnerInput := cli.readLine()\n\twinner, err := extractWinner(winnerInput)\n\n\tif err != nil {\n\t\tfmt.Fprint(cli.out, BadWinnerInputMsg)\n\t\treturn\n\t}\n\n\tcli.game.Finish(winner)\n}\n\nfunc extractWinner(userInput string) (string, error) {\n\tif !strings.Contains(userInput, \" wins\") {\n\t\treturn \"\", errors.New(BadWinnerInputMsg)\n\t}\n\treturn strings.Replace(userInput, \" wins\", \"\", 1), nil\n}\n\nfunc (cli *CLI) readLine() string {\n\tcli.in.Scan()\n\treturn cli.in.Text()\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sort\"\n)\n\n// FileSystemPlayerStore stores players in the filesystem.\ntype FileSystemPlayerStore struct {\n\tdatabase *json.Encoder\n\tleague   League\n}\n\n// NewFileSystemPlayerStore creates a FileSystemPlayerStore initialising the store if needed.\nfunc NewFileSystemPlayerStore(file *os.File) (*FileSystemPlayerStore, error) {\n\n\terr := initialisePlayerDBFile(file)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"problem initialising player db file, %v\", err)\n\t}\n\n\tleague, err := NewLeague(file)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"problem loading player store from file %s, %v\", file.Name(), err)\n\t}\n\n\treturn &FileSystemPlayerStore{\n\t\tdatabase: json.NewEncoder(&Tape{file}),\n\t\tleague:   league,\n\t}, nil\n}\n\n// FileSystemPlayerStoreFromFile creates a PlayerStore from the contents of a JSON file found at path.\nfunc FileSystemPlayerStoreFromFile(path string) (*FileSystemPlayerStore, func(), error) {\n\tdb, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE, 0666)\n\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"problem opening %s %v\", path, err)\n\t}\n\n\tcloseFunc := func() {\n\t\tdb.Close()\n\t}\n\n\tstore, err := NewFileSystemPlayerStore(db)\n\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"problem creating file system player store, %v \", err)\n\t}\n\n\treturn store, closeFunc, nil\n}\n\nfunc initialisePlayerDBFile(file *os.File) error {\n\tfile.Seek(0, io.SeekStart)\n\n\tinfo, err := file.Stat()\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"problem getting file info from file %s, %v\", file.Name(), err)\n\t}\n\n\tif info.Size() == 0 {\n\t\tfile.Write([]byte(\"[]\"))\n\t\tfile.Seek(0, io.SeekStart)\n\t}\n\n\treturn nil\n}\n\n// GetLeague returns the Scores of all the players.\nfunc (f *FileSystemPlayerStore) GetLeague() League {\n\tsort.Slice(f.league, func(i, j int) bool {\n\t\treturn f.league[i].Wins > f.league[j].Wins\n\t})\n\treturn f.league\n}\n\n// GetPlayerScore retrieves a player's score.\nfunc (f *FileSystemPlayerStore) GetPlayerScore(name string) int {\n\n\tplayer := f.league.Find(name)\n\n\tif player != nil {\n\t\treturn player.Wins\n\t}\n\n\treturn 0\n}\n\n// RecordWin will store a win for a player, incrementing wins if already known.\nfunc (f *FileSystemPlayerStore) RecordWin(name string) {\n\tplayer := f.league.Find(name)\n\n\tif player != nil {\n\t\tplayer.Wins++\n\t} else {\n\t\tf.league = append(f.league, Player{name, 1})\n\t}\n\n\tf.database.Encode(f.league)\n}\n\npackage poker\n\nimport \"io\"\n\n// Game manages the state of a game.\ntype Game interface {\n\tStart(numberOfPlayers int, alertsDestination io.Writer)\n\tFinish(winner string)\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n)\n\n// League stores a collection of players.\ntype League []Player\n\n// Find tries to return a player from a League.\nfunc (l League) Find(name string) *Player {\n\tfor i, p := range l {\n\t\tif p.Name == name {\n\t\t\treturn &l[i]\n\t\t}\n\t}\n\treturn nil\n}\n\n// NewLeague creates a League from JSON.\nfunc NewLeague(rdr io.Reader) (League, error) {\n\tvar league []Player\n\terr := json.NewDecoder(rdr).Decode(&league)\n\n\tif err != nil {\n\t\terr = fmt.Errorf(\"problem parsing League, %v\", err)\n\t}\n\n\treturn league, err\n}\n\npackage poker\n\nimport (\n\t\"github.com/gorilla/websocket\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype playerServerWS struct {\n\t*websocket.Conn\n}\n\nfunc (w *playerServerWS) Write(p []byte) (n int, err error) {\n\terr = w.WriteMessage(websocket.TextMessage, p)\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn len(p), nil\n}\n\nfunc newPlayerServerWS(w http.ResponseWriter, r *http.Request) *playerServerWS {\n\tconn, err := wsUpgrader.Upgrade(w, r, nil)\n\n\tif err != nil {\n\t\tlog.Printf(\"problem upgrading connection to websockets %v\\n\", err)\n\t}\n\n\treturn &playerServerWS{conn}\n}\n\nfunc (w *playerServerWS) WaitForMsg() string {\n\t_, msg, err := w.ReadMessage()\n\tif err != nil {\n\t\tlog.Printf(\"error reading from websocket %v\\n\", err)\n\t}\n\treturn string(msg)\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// PlayerStore stores score information about players.\ntype PlayerStore interface {\n\tGetPlayerScore(name string) int\n\tRecordWin(name string)\n\tGetLeague() League\n}\n\n// Player stores a name with a number of wins.\ntype Player struct {\n\tName string\n\tWins int\n}\n\n// PlayerServer is a HTTP interface for player information.\ntype PlayerServer struct {\n\tstore PlayerStore\n\thttp.Handler\n\ttemplate *template.Template\n\tgame     Game\n}\n\nconst jsonContentType = \"application/json\"\nconst htmlTemplatePath = \"game.html\"\n\n// NewPlayerServer creates a PlayerServer with routing configured.\nfunc NewPlayerServer(store PlayerStore, game Game) (*PlayerServer, error) {\n\tp := new(PlayerServer)\n\n\ttmpl, err := template.ParseFiles(htmlTemplatePath)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"problem opening %s %v\", htmlTemplatePath, err)\n\t}\n\n\tp.game = game\n\tp.template = tmpl\n\tp.store = store\n\n\trouter := http.NewServeMux()\n\trouter.Handle(\"/league\", http.HandlerFunc(p.leagueHandler))\n\trouter.Handle(\"/players/\", http.HandlerFunc(p.playersHandler))\n\trouter.Handle(\"/game\", http.HandlerFunc(p.playGame))\n\trouter.Handle(\"/ws\", http.HandlerFunc(p.webSocket))\n\n\tp.Handler = router\n\n\treturn p, nil\n}\n\nvar wsUpgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nfunc (p *PlayerServer) webSocket(w http.ResponseWriter, r *http.Request) {\n\tws := newPlayerServerWS(w, r)\n\n\tnumberOfPlayersMsg := ws.WaitForMsg()\n\tnumberOfPlayers, _ := strconv.Atoi(numberOfPlayersMsg)\n\tp.game.Start(numberOfPlayers, ws)\n\n\twinner := ws.WaitForMsg()\n\tp.game.Finish(winner)\n}\n\nfunc (p *PlayerServer) playGame(w http.ResponseWriter, r *http.Request) {\n\tp.template.Execute(w, nil)\n}\n\nfunc (p *PlayerServer) leagueHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", jsonContentType)\n\tjson.NewEncoder(w).Encode(p.store.GetLeague())\n}\n\nfunc (p *PlayerServer) playersHandler(w http.ResponseWriter, r *http.Request) {\n\tplayer := strings.TrimPrefix(r.URL.Path, \"/players/\")\n\n\tswitch r.Method {\n\tcase http.MethodPost:\n\t\tp.processWin(w, player)\n\tcase http.MethodGet:\n\t\tp.showScore(w, player)\n\t}\n}\n\nfunc (p *PlayerServer) showScore(w http.ResponseWriter, player string) {\n\tscore := p.store.GetPlayerScore(player)\n\n\tif score == 0 {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t}\n\n\tfmt.Fprint(w, score)\n}\n\nfunc (p *PlayerServer) processWin(w http.ResponseWriter, player string) {\n\tp.store.RecordWin(player)\n\tw.WriteHeader(http.StatusAccepted)\n}\n\npackage poker\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\n// Tape represents an os.File that will re-write from the start on every Write call.\ntype Tape struct {\n\tFile *os.File\n}\n\nfunc (t *Tape) Write(p []byte) (n int, err error) {\n\tt.File.Truncate(0)\n\tt.File.Seek(0, io.SeekStart)\n\treturn t.File.Write(p)\n}\n\npackage poker\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n)\n\n// StubPlayerStore implements PlayerStore for testing purposes.\ntype StubPlayerStore struct {\n\tScores   map[string]int\n\tWinCalls []string\n\tLeague   []Player\n}\n\n// GetPlayerScore returns a score from Scores.\nfunc (s *StubPlayerStore) GetPlayerScore(name string) int {\n\tscore := s.Scores[name]\n\treturn score\n}\n\n// RecordWin will record a win to WinCalls.\nfunc (s *StubPlayerStore) RecordWin(name string) {\n\ts.WinCalls = append(s.WinCalls, name)\n}\n\n// GetLeague returns League.\nfunc (s *StubPlayerStore) GetLeague() League {\n\treturn s.League\n}\n\n// AssertPlayerWin allows you to spy on the store's calls to RecordWin.\nfunc AssertPlayerWin(t testing.TB, store *StubPlayerStore, winner string) {\n\tt.Helper()\n\n\tif len(store.WinCalls) != 1 {\n\t\tt.Fatalf(\"got %d calls to RecordWin want %d\", len(store.WinCalls), 1)\n\t}\n\n\tif store.WinCalls[0] != winner {\n\t\tt.Errorf(\"did not store correct winner got %q want %q\", store.WinCalls[0], winner)\n\t}\n}\n\n// ScheduledAlert holds information about when an alert is scheduled.\ntype ScheduledAlert struct {\n\tAt     time.Duration\n\tAmount int\n}\n\nfunc (s ScheduledAlert) String() string {\n\treturn fmt.Sprintf(\"%d chips at %v\", s.Amount, s.At)\n}\n\n// SpyBlindAlerter allows you to spy on ScheduleAlertAt calls.\ntype SpyBlindAlerter struct {\n\tAlerts []ScheduledAlert\n}\n\n// ScheduleAlertAt records alerts that have been scheduled.\nfunc (s *SpyBlindAlerter) ScheduleAlertAt(at time.Duration, amount int, to io.Writer) {\n\ts.Alerts = append(s.Alerts, ScheduledAlert{at, amount})\n}\n\npackage poker\n\nimport (\n\t\"io\"\n\t\"time\"\n)\n\n// TexasHoldem manages a game of poker.\ntype TexasHoldem struct {\n\talerter BlindAlerter\n\tstore   PlayerStore\n}\n\n// NewTexasHoldem returns a new game.\nfunc NewTexasHoldem(alerter BlindAlerter, store PlayerStore) *TexasHoldem {\n\treturn &TexasHoldem{\n\t\talerter: alerter,\n\t\tstore:   store,\n\t}\n}\n\n// Start will schedule blind alerts dependant on the number of players.\nfunc (p *TexasHoldem) Start(numberOfPlayers int, alertsDestination io.Writer) {\n\tblindIncrement := time.Duration(5+numberOfPlayers) * time.Minute\n\n\tblinds := []int{100, 200, 300, 400, 500, 600, 800, 1000, 2000, 4000, 8000}\n\tblindTime := 0 * time.Second\n\tfor _, blind := range blinds {\n\t\tp.alerter.ScheduleAlertAt(blindTime, blind, alertsDestination)\n\t\tblindTime = blindTime + blindIncrement\n\t}\n}\n\n// Finish ends the game, recording the winner.\nfunc (p *TexasHoldem) Finish(winner string) {\n\tp.store.RecordWin(winner)\n}",
  "test_code": "package poker_test\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\tpoker \"github.com/quii/learn-go-with-tests/websockets/v2\"\n)\n\nvar dummyBlindAlerter = &poker.SpyBlindAlerter{}\nvar dummyPlayerStore = &poker.StubPlayerStore{}\nvar dummyStdIn = &bytes.Buffer{}\nvar dummyStdOut = &bytes.Buffer{}\n\ntype GameSpy struct {\n\tStartCalled     bool\n\tStartCalledWith int\n\tBlindAlert      []byte\n\n\tFinishedCalled   bool\n\tFinishCalledWith string\n}\n\nfunc (g *GameSpy) Start(numberOfPlayers int, out io.Writer) {\n\tg.StartCalled = true\n\tg.StartCalledWith = numberOfPlayers\n\tout.Write(g.BlindAlert)\n}\n\nfunc (g *GameSpy) Finish(winner string) {\n\tg.FinishedCalled = true\n\tg.FinishCalledWith = winner\n}\n\nfunc userSends(messages ...string) io.Reader {\n\treturn strings.NewReader(strings.Join(messages, \"\\n\"))\n}\n\nfunc TestCLI(t *testing.T) {\n\n\tt.Run(\"start game with 3 players and finish game with 'Chris' as winner\", func(t *testing.T) {\n\t\tgame := &GameSpy{}\n\n\t\tout := &bytes.Buffer{}\n\t\tin := userSends(\"3\", \"Chris wins\")\n\n\t\tpoker.NewCLI(in, out, game).PlayPoker()\n\n\t\tassertMessagesSentToUser(t, out, poker.PlayerPrompt)\n\t\tassertGameStartedWith(t, game, 3)\n\t\tassertFinishCalledWith(t, game, \"Chris\")\n\t})\n\n\tt.Run(\"start game with 8 players and record 'Cleo' as winner\", func(t *testing.T) {\n\t\tgame := &GameSpy{}\n\n\t\tin := userSends(\"8\", \"Cleo wins\")\n\n\t\tpoker.NewCLI(in, dummyStdOut, game).PlayPoker()\n\n\t\tassertGameStartedWith(t, game, 8)\n\t\tassertFinishCalledWith(t, game, \"Cleo\")\n\t})\n\n\tt.Run(\"it prints an error when a non numeric value is entered and does not start the game\", func(t *testing.T) {\n\t\tgame := &GameSpy{}\n\n\t\tout := &bytes.Buffer{}\n\t\tin := userSends(\"pies\")\n\n\t\tpoker.NewCLI(in, out, game).PlayPoker()\n\n\t\tassertGameNotStarted(t, game)\n\t\tassertMessagesSentToUser(t, out, poker.PlayerPrompt, poker.BadPlayerInputErrMsg)\n\t})\n\n\tt.Run(\"it prints an error when the winner is declared incorrectly\", func(t *testing.T) {\n\t\tgame := &GameSpy{}\n\n\t\tout := &bytes.Buffer{}\n\t\tin := userSends(\"8\", \"Lloyd is a killer\")\n\n\t\tpoker.NewCLI(in, out, game).PlayPoker()\n\n\t\tassertGameNotFinished(t, game)\n\t\tassertMessagesSentToUser(t, out, poker.PlayerPrompt, poker.BadWinnerInputMsg)\n\t})\n}\n\nfunc assertGameStartedWith(t testing.TB, game *GameSpy, numberOfPlayersWanted int) {\n\tt.Helper()\n\n\tpassed := retryUntil(500*time.Millisecond, func() bool {\n\t\treturn game.StartCalledWith == numberOfPlayersWanted\n\t})\n\n\tif !passed {\n\t\tt.Errorf(\"wanted Start called with %d but got %d\", numberOfPlayersWanted, game.StartCalledWith)\n\t}\n}\n\nfunc assertGameNotFinished(t testing.TB, game *GameSpy) {\n\tt.Helper()\n\tif game.FinishedCalled {\n\t\tt.Errorf(\"game should not have finished\")\n\t}\n}\n\nfunc assertGameNotStarted(t testing.TB, game *GameSpy) {\n\tt.Helper()\n\tif game.StartCalled {\n\t\tt.Errorf(\"game should not have started\")\n\t}\n}\n\nfunc assertFinishCalledWith(t testing.TB, game *GameSpy, winner string) {\n\tt.Helper()\n\n\tpassed := retryUntil(500*time.Millisecond, func() bool {\n\t\treturn game.FinishCalledWith == winner\n\t})\n\n\tif !passed {\n\t\tt.Errorf(\"expected finish called with %q but got %q\", winner, game.FinishCalledWith)\n\t}\n}\n\nfunc assertMessagesSentToUser(t testing.TB, stdout *bytes.Buffer, messages ...string) {\n\tt.Helper()\n\twant := strings.Join(messages, \"\")\n\tgot := stdout.String()\n\tif got != want {\n\t\tt.Errorf(\"got %q sent to stdout but expected %+v\", got, messages)\n\t}\n}\n\nfunc assertScheduledAlert(t testing.TB, got, want poker.ScheduledAlert) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"got %+v, want %+v\", got, want)\n\t}\n}\n\npackage poker_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\tpoker \"github.com/quii/learn-go-with-tests/websockets/v2\"\n)\n\nfunc createTempFile(t testing.TB, initialData string) (*os.File, func()) {\n\tt.Helper()\n\n\ttmpfile, err := os.CreateTemp(\"\", \"db\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"could not create temp file %v\", err)\n\t}\n\n\ttmpfile.Write([]byte(initialData))\n\n\tremoveFile := func() {\n\t\ttmpfile.Close()\n\t\tos.Remove(tmpfile.Name())\n\t}\n\n\treturn tmpfile, removeFile\n}\n\nfunc TestFileSystemStore(t *testing.T) {\n\n\tt.Run(\"League sorted\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := poker.NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tgot := store.GetLeague()\n\n\t\twant := []poker.Player{\n\t\t\t{Name: \"Chris\", Wins: 33},\n\t\t\t{Name: \"Cleo\", Wins: 10},\n\t\t}\n\n\t\tassertLeague(t, got, want)\n\n\t\t// read again\n\t\tgot = store.GetLeague()\n\t\tassertLeague(t, got, want)\n\t})\n\n\tt.Run(\"get player score\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := poker.NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tgot := store.GetPlayerScore(\"Chris\")\n\t\twant := 33\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"store wins for existing players\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := poker.NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tstore.RecordWin(\"Chris\")\n\n\t\tgot := store.GetPlayerScore(\"Chris\")\n\t\twant := 34\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"store wins for existing players\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := poker.NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tstore.RecordWin(\"Pepper\")\n\n\t\tgot := store.GetPlayerScore(\"Pepper\")\n\t\twant := 1\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"works with an empty file\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, \"\")\n\t\tdefer cleanDatabase()\n\n\t\t_, err := poker.NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\t})\n}\n\nfunc assertScoreEquals(t testing.TB, got, want int) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"got %d want %d\", got, want)\n\t}\n}\n\nfunc assertNoError(t testing.TB, err error) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatalf(\"didn't expect an error but got one, %v\", err)\n\t}\n}\n\npackage poker_test\n\nimport (\n\t\"github.com/quii/learn-go-with-tests/websockets/v2\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc TestRecordingWinsAndRetrievingThem(t *testing.T) {\n\tdatabase, cleanDatabase := createTempFile(t, `[]`)\n\tdefer cleanDatabase()\n\tstore, err := poker.NewFileSystemPlayerStore(database)\n\n\tassertNoError(t, err)\n\n\tserver := mustMakePlayerServer(t, store, dummyGame)\n\tplayer := \"Pepper\"\n\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\n\tt.Run(\"get score\", func(t *testing.T) {\n\t\tresponse := httptest.NewRecorder()\n\t\tserver.ServeHTTP(response, newGetScoreRequest(player))\n\t\tassertStatus(t, response, http.StatusOK)\n\n\t\tassertResponseBody(t, response.Body.String(), \"3\")\n\t})\n\n\tt.Run(\"get League\", func(t *testing.T) {\n\t\tresponse := httptest.NewRecorder()\n\t\tserver.ServeHTTP(response, newLeagueRequest())\n\t\tassertStatus(t, response, http.StatusOK)\n\n\t\tgot := getLeagueFromResponse(t, response.Body)\n\t\twant := []poker.Player{\n\t\t\t{Name: \"Pepper\", Wins: 3},\n\t\t}\n\t\tassertLeague(t, got, want)\n\t})\n}\n\npackage poker_test\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\tpoker \"github.com/quii/learn-go-with-tests/websockets/v2\"\n)\n\nvar (\n\tdummyGame = &GameSpy{}\n\ttenMS     = 10 * time.Millisecond\n)\n\nfunc mustMakePlayerServer(t *testing.T, store poker.PlayerStore, game poker.Game) *poker.PlayerServer {\n\tserver, err := poker.NewPlayerServer(store, game)\n\tif err != nil {\n\t\tt.Fatal(\"problem creating player server\", err)\n\t}\n\treturn server\n}\n\nfunc TestGETPlayers(t *testing.T) {\n\tstore := poker.StubPlayerStore{\n\t\tScores: map[string]int{\n\t\t\t\"Pepper\": 20,\n\t\t\t\"Floyd\":  10,\n\t\t},\n\t}\n\tserver := mustMakePlayerServer(t, &store, dummyGame)\n\n\tt.Run(\"returns Pepper's score\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Pepper\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response, http.StatusOK)\n\t\tassertResponseBody(t, response.Body.String(), \"20\")\n\t})\n\n\tt.Run(\"returns Floyd's score\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Floyd\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response, http.StatusOK)\n\t\tassertResponseBody(t, response.Body.String(), \"10\")\n\t})\n\n\tt.Run(\"returns 404 on missing players\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Apollo\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response, http.StatusNotFound)\n\t})\n}\n\nfunc TestStoreWins(t *testing.T) {\n\tstore := poker.StubPlayerStore{\n\t\tScores: map[string]int{},\n\t}\n\tserver := mustMakePlayerServer(t, &store, dummyGame)\n\n\tt.Run(\"it records wins on POST\", func(t *testing.T) {\n\t\tplayer := \"Pepper\"\n\n\t\trequest := newPostWinRequest(player)\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response, http.StatusAccepted)\n\t\tpoker.AssertPlayerWin(t, &store, player)\n\t})\n}\n\nfunc TestLeague(t *testing.T) {\n\n\tt.Run(\"it returns the League table as JSON\", func(t *testing.T) {\n\t\twantedLeague := []poker.Player{\n\t\t\t{Name: \"Cleo\", Wins: 32},\n\t\t\t{Name: \"Chris\", Wins: 20},\n\t\t\t{Name: \"Tiest\", Wins: 14},\n\t\t}\n\n\t\tstore := poker.StubPlayerStore{League: wantedLeague}\n\t\tserver := mustMakePlayerServer(t, &store, dummyGame)\n\n\t\trequest := newLeagueRequest()\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tgot := getLeagueFromResponse(t, response.Body)\n\n\t\tassertStatus(t, response, http.StatusOK)\n\t\tassertLeague(t, got, wantedLeague)\n\t\tassertContentType(t, response, \"application/json\")\n\n\t})\n}\n\nfunc TestGame(t *testing.T) {\n\tt.Run(\"GET /game returns 200\", func(t *testing.T) {\n\t\tserver := mustMakePlayerServer(t, &poker.StubPlayerStore{}, dummyGame)\n\n\t\trequest := newGameRequest()\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response, http.StatusOK)\n\t})\n\n\tt.Run(\"start a game with 3 players, send some blind alerts down WS and declare Ruth the winner\", func(t *testing.T) {\n\t\twantedBlindAlert := \"Blind is 100\"\n\t\twinner := \"Ruth\"\n\n\t\tgame := &GameSpy{BlindAlert: []byte(wantedBlindAlert)}\n\t\tserver := httptest.NewServer(mustMakePlayerServer(t, dummyPlayerStore, game))\n\t\tws := mustDialWS(t, \"ws\"+strings.TrimPrefix(server.URL, \"http\")+\"/ws\")\n\n\t\tdefer server.Close()\n\t\tdefer ws.Close()\n\n\t\twriteWSMessage(t, ws, \"3\")\n\t\twriteWSMessage(t, ws, winner)\n\n\t\tassertGameStartedWith(t, game, 3)\n\t\tassertFinishCalledWith(t, game, winner)\n\t\twithin(t, tenMS, func() { assertWebsocketGotMsg(t, ws, wantedBlindAlert) })\n\t})\n}\n\nfunc assertWebsocketGotMsg(t *testing.T, ws *websocket.Conn, want string) {\n\t_, msg, _ := ws.ReadMessage()\n\tif string(msg) != want {\n\t\tt.Errorf(`got \"%s\", want \"%s\"`, string(msg), want)\n\t}\n}\n\nfunc retryUntil(d time.Duration, f func() bool) bool {\n\tdeadline := time.Now().Add(d)\n\tfor time.Now().Before(deadline) {\n\t\tif f() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc within(t testing.TB, d time.Duration, assert func()) {\n\tt.Helper()\n\n\tdone := make(chan struct{}, 1)\n\n\tgo func() {\n\t\tassert()\n\t\tdone <- struct{}{}\n\t}()\n\n\tselect {\n\tcase <-time.After(d):\n\t\tt.Error(\"timed out\")\n\tcase <-done:\n\t}\n}\n\nfunc writeWSMessage(t testing.TB, conn *websocket.Conn, message string) {\n\tt.Helper()\n\tif err := conn.WriteMessage(websocket.TextMessage, []byte(message)); err != nil {\n\t\tt.Fatalf(\"could not send message over ws connection %v\", err)\n\t}\n}\n\nfunc assertContentType(t testing.TB, response *httptest.ResponseRecorder, want string) {\n\tt.Helper()\n\tif response.Header().Get(\"content-type\") != want {\n\t\tt.Errorf(\"response did not have content-type of %s, got %v\", want, response.Result().Header)\n\t}\n}\n\nfunc getLeagueFromResponse(t *testing.T, body io.Reader) []poker.Player {\n\tt.Helper()\n\tleague, err := poker.NewLeague(body)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to parse response from server %q into slice of Player, '%v'\", body, err)\n\t}\n\n\treturn league\n}\n\nfunc assertLeague(t *testing.T, got, want []poker.Player) {\n\tt.Helper()\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\nfunc assertStatus(t *testing.T, got *httptest.ResponseRecorder, want int) {\n\tt.Helper()\n\tif got.Code != want {\n\t\tt.Errorf(\"did not get correct status, got %d, want %d\", got.Code, want)\n\t}\n}\n\nfunc newGameRequest() *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, \"/game\", nil)\n\treturn req\n}\n\nfunc newLeagueRequest() *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, \"/league\", nil)\n\treturn req\n}\n\nfunc newGetScoreRequest(name string) *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, fmt.Sprintf(\"/players/%s\", name), nil)\n\treturn req\n}\n\nfunc newPostWinRequest(name string) *http.Request {\n\treq, _ := http.NewRequest(http.MethodPost, fmt.Sprintf(\"/players/%s\", name), nil)\n\treturn req\n}\n\nfunc assertResponseBody(t *testing.T, got, want string) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"response body is wrong, got %q want %q\", got, want)\n\t}\n}\n\nfunc mustDialWS(t *testing.T, url string) *websocket.Conn {\n\tws, _, err := websocket.DefaultDialer.Dial(url, nil)\n\n\tif err != nil {\n\t\tt.Fatalf(\"could not open a ws connection on %s %v\", url, err)\n\t}\n\n\treturn ws\n}\n\npackage poker_test\n\nimport (\n\t\"io\"\n\t\"testing\"\n\n\tpoker \"github.com/quii/learn-go-with-tests/websockets/v2\"\n)\n\nfunc TestTape_Write(t *testing.T) {\n\tfile, clean := createTempFile(t, \"12345\")\n\tdefer clean()\n\n\ttape := &poker.Tape{File: file}\n\n\ttape.Write([]byte(\"abc\"))\n\n\tfile.Seek(0, io.SeekStart)\n\tnewFileContents, _ := io.ReadAll(file)\n\n\tgot := string(newFileContents)\n\twant := \"abc\"\n\n\tif got != want {\n\t\tt.Errorf(\"got %q want %q\", got, want)\n\t}\n}\n\npackage poker_test\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n\n\tpoker \"github.com/quii/learn-go-with-tests/websockets/v2\"\n)\n\nfunc TestGame_Start(t *testing.T) {\n\tt.Run(\"schedules alerts on game start for 5 players\", func(t *testing.T) {\n\t\tblindAlerter := &poker.SpyBlindAlerter{}\n\t\tgame := poker.NewTexasHoldem(blindAlerter, dummyPlayerStore)\n\n\t\tgame.Start(5, io.Discard)\n\n\t\tcases := []poker.ScheduledAlert{\n\t\t\t{At: 0 * time.Second, Amount: 100},\n\t\t\t{At: 10 * time.Minute, Amount: 200},\n\t\t\t{At: 20 * time.Minute, Amount: 300},\n\t\t\t{At: 30 * time.Minute, Amount: 400},\n\t\t\t{At: 40 * time.Minute, Amount: 500},\n\t\t\t{At: 50 * time.Minute, Amount: 600},\n\t\t\t{At: 60 * time.Minute, Amount: 800},\n\t\t\t{At: 70 * time.Minute, Amount: 1000},\n\t\t\t{At: 80 * time.Minute, Amount: 2000},\n\t\t\t{At: 90 * time.Minute, Amount: 4000},\n\t\t\t{At: 100 * time.Minute, Amount: 8000},\n\t\t}\n\n\t\tcheckSchedulingCases(cases, t, blindAlerter)\n\t})\n\n\tt.Run(\"schedules alerts on game start for 7 players\", func(t *testing.T) {\n\t\tblindAlerter := &poker.SpyBlindAlerter{}\n\t\tgame := poker.NewTexasHoldem(blindAlerter, dummyPlayerStore)\n\n\t\tgame.Start(7, io.Discard)\n\n\t\tcases := []poker.ScheduledAlert{\n\t\t\t{At: 0 * time.Second, Amount: 100},\n\t\t\t{At: 12 * time.Minute, Amount: 200},\n\t\t\t{At: 24 * time.Minute, Amount: 300},\n\t\t\t{At: 36 * time.Minute, Amount: 400},\n\t\t}\n\n\t\tcheckSchedulingCases(cases, t, blindAlerter)\n\t})\n\n}\n\nfunc TestGame_Finish(t *testing.T) {\n\tstore := &poker.StubPlayerStore{}\n\tgame := poker.NewTexasHoldem(dummyBlindAlerter, store)\n\twinner := \"Ruth\"\n\n\tgame.Finish(winner)\n\tpoker.AssertPlayerWin(t, store, winner)\n}\n\nfunc checkSchedulingCases(cases []poker.ScheduledAlert, t *testing.T, blindAlerter *poker.SpyBlindAlerter) {\n\tfor i, want := range cases {\n\t\tt.Run(fmt.Sprint(want), func(t *testing.T) {\n\n\t\t\tif len(blindAlerter.Alerts) <= i {\n\t\t\t\tt.Fatalf(\"alert %d was not scheduled %v\", i, blindAlerter.Alerts)\n\t\t\t}\n\n\t\t\tgot := blindAlerter.Alerts[i]\n\t\t\tassertScheduledAlert(t, got, want)\n\t\t})\n\t}\n}",
  "difficulty": "Fácil"
}
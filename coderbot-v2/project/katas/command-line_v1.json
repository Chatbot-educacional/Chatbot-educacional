{
  "title": "V1",
  "content": "FileSystemPlayerStore stores players in the filesystem.",
  "correct_code": "package poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sort\"\n)\n\n// FileSystemPlayerStore stores players in the filesystem.\ntype FileSystemPlayerStore struct {\n\tdatabase *json.Encoder\n\tleague   League\n}\n\n// NewFileSystemPlayerStore creates a FileSystemPlayerStore initialising the store if needed.\nfunc NewFileSystemPlayerStore(file *os.File) (*FileSystemPlayerStore, error) {\n\n\terr := initialisePlayerDBFile(file)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"problem initialising player db file, %v\", err)\n\t}\n\n\tleague, err := NewLeague(file)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"problem loading player store from file %s, %v\", file.Name(), err)\n\t}\n\n\treturn &FileSystemPlayerStore{\n\t\tdatabase: json.NewEncoder(&tape{file}),\n\t\tleague:   league,\n\t}, nil\n}\n\nfunc initialisePlayerDBFile(file *os.File) error {\n\tfile.Seek(0, io.SeekStart)\n\n\tinfo, err := file.Stat()\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"problem getting file info from file %s, %v\", file.Name(), err)\n\t}\n\n\tif info.Size() == 0 {\n\t\tfile.Write([]byte(\"[]\"))\n\t\tfile.Seek(0, io.SeekStart)\n\t}\n\n\treturn nil\n}\n\n// GetLeague returns the scores of all the players.\nfunc (f *FileSystemPlayerStore) GetLeague() League {\n\tsort.Slice(f.league, func(i, j int) bool {\n\t\treturn f.league[i].Wins > f.league[j].Wins\n\t})\n\treturn f.league\n}\n\n// GetPlayerScore retrieves a player's score.\nfunc (f *FileSystemPlayerStore) GetPlayerScore(name string) int {\n\n\tplayer := f.league.Find(name)\n\n\tif player != nil {\n\t\treturn player.Wins\n\t}\n\n\treturn 0\n}\n\n// RecordWin will store a win for a player, incrementing wins if already known.\nfunc (f *FileSystemPlayerStore) RecordWin(name string) {\n\tplayer := f.league.Find(name)\n\n\tif player != nil {\n\t\tplayer.Wins++\n\t} else {\n\t\tf.league = append(f.league, Player{name, 1})\n\t}\n\n\tf.database.Encode(f.league)\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n)\n\n// League stores a collection of players.\ntype League []Player\n\n// Find tries to return a player from a league.\nfunc (l League) Find(name string) *Player {\n\tfor i, p := range l {\n\t\tif p.Name == name {\n\t\t\treturn &l[i]\n\t\t}\n\t}\n\treturn nil\n}\n\n// NewLeague creates a league from JSON.\nfunc NewLeague(rdr io.Reader) (League, error) {\n\tvar league []Player\n\terr := json.NewDecoder(rdr).Decode(&league)\n\n\tif err != nil {\n\t\terr = fmt.Errorf(\"problem parsing league, %v\", err)\n\t}\n\n\treturn league, err\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// PlayerStore stores score information about players.\ntype PlayerStore interface {\n\tGetPlayerScore(name string) int\n\tRecordWin(name string)\n\tGetLeague() League\n}\n\n// Player stores a name with a number of wins.\ntype Player struct {\n\tName string\n\tWins int\n}\n\n// PlayerServer is a HTTP interface for player information.\ntype PlayerServer struct {\n\tstore PlayerStore\n\thttp.Handler\n}\n\nconst jsonContentType = \"application/json\"\n\n// NewPlayerServer creates a PlayerServer with routing configured.\nfunc NewPlayerServer(store PlayerStore) *PlayerServer {\n\tp := new(PlayerServer)\n\n\tp.store = store\n\n\trouter := http.NewServeMux()\n\trouter.Handle(\"/league\", http.HandlerFunc(p.leagueHandler))\n\trouter.Handle(\"/players/\", http.HandlerFunc(p.playersHandler))\n\n\tp.Handler = router\n\n\treturn p\n}\n\nfunc (p *PlayerServer) leagueHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", jsonContentType)\n\tjson.NewEncoder(w).Encode(p.store.GetLeague())\n}\n\nfunc (p *PlayerServer) playersHandler(w http.ResponseWriter, r *http.Request) {\n\tplayer := strings.TrimPrefix(r.URL.Path, \"/players/\")\n\n\tswitch r.Method {\n\tcase http.MethodPost:\n\t\tp.processWin(w, player)\n\tcase http.MethodGet:\n\t\tp.showScore(w, player)\n\t}\n}\n\nfunc (p *PlayerServer) showScore(w http.ResponseWriter, player string) {\n\tscore := p.store.GetPlayerScore(player)\n\n\tif score == 0 {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t}\n\n\tfmt.Fprint(w, score)\n}\n\nfunc (p *PlayerServer) processWin(w http.ResponseWriter, player string) {\n\tp.store.RecordWin(player)\n\tw.WriteHeader(http.StatusAccepted)\n}\n\npackage poker\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\ntype tape struct {\n\tfile *os.File\n}\n\nfunc (t *tape) Write(p []byte) (n int, err error) {\n\tt.file.Truncate(0)\n\tt.file.Seek(0, io.SeekStart)\n\treturn t.file.Write(p)\n}",
  "test_code": "package poker\n\nimport (\n\t\"os\"\n\t\"testing\"\n)\n\nfunc createTempFile(t testing.TB, initialData string) (*os.File, func()) {\n\tt.Helper()\n\n\ttmpfile, err := os.CreateTemp(\"\", \"db\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"could not create temp file %v\", err)\n\t}\n\n\ttmpfile.Write([]byte(initialData))\n\n\tremoveFile := func() {\n\t\tos.Remove(tmpfile.Name())\n\t}\n\n\treturn tmpfile, removeFile\n}\n\nfunc TestFileSystemStore(t *testing.T) {\n\n\tt.Run(\"league sorted\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tgot := store.GetLeague()\n\n\t\twant := []Player{\n\t\t\t{\"Chris\", 33},\n\t\t\t{\"Cleo\", 10},\n\t\t}\n\n\t\tassertLeague(t, got, want)\n\n\t\t// read again\n\t\tgot = store.GetLeague()\n\t\tassertLeague(t, got, want)\n\t})\n\n\tt.Run(\"get player score\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tgot := store.GetPlayerScore(\"Chris\")\n\t\twant := 33\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"store wins for existing players\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tstore.RecordWin(\"Chris\")\n\n\t\tgot := store.GetPlayerScore(\"Chris\")\n\t\twant := 34\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"store wins for existing players\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tstore.RecordWin(\"Pepper\")\n\n\t\tgot := store.GetPlayerScore(\"Pepper\")\n\t\twant := 1\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"works with an empty file\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, \"\")\n\t\tdefer cleanDatabase()\n\n\t\t_, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\t})\n}\n\nfunc assertScoreEquals(t testing.TB, got, want int) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"got %d want %d\", got, want)\n\t}\n}\n\nfunc assertNoError(t testing.TB, err error) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatalf(\"didn't expect an error but got one, %v\", err)\n\t}\n}\n\npackage poker\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc TestRecordingWinsAndRetrievingThem(t *testing.T) {\n\tdatabase, cleanDatabase := createTempFile(t, `[]`)\n\tdefer cleanDatabase()\n\tstore, err := NewFileSystemPlayerStore(database)\n\n\tassertNoError(t, err)\n\n\tserver := NewPlayerServer(store)\n\tplayer := \"Pepper\"\n\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\n\tt.Run(\"get score\", func(t *testing.T) {\n\t\tresponse := httptest.NewRecorder()\n\t\tserver.ServeHTTP(response, newGetScoreRequest(player))\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\n\t\tassertResponseBody(t, response.Body.String(), \"3\")\n\t})\n\n\tt.Run(\"get league\", func(t *testing.T) {\n\t\tresponse := httptest.NewRecorder()\n\t\tserver.ServeHTTP(response, newLeagueRequest())\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\n\t\tgot := getLeagueFromResponse(t, response.Body)\n\t\twant := []Player{\n\t\t\t{\"Pepper\", 3},\n\t\t}\n\t\tassertLeague(t, got, want)\n\t})\n}\n\npackage poker\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype StubPlayerStore struct {\n\tscores   map[string]int\n\twinCalls []string\n\tleague   []Player\n}\n\nfunc (s *StubPlayerStore) GetPlayerScore(name string) int {\n\tscore := s.scores[name]\n\treturn score\n}\n\nfunc (s *StubPlayerStore) RecordWin(name string) {\n\ts.winCalls = append(s.winCalls, name)\n}\n\nfunc (s *StubPlayerStore) GetLeague() League {\n\treturn s.league\n}\n\nfunc TestGETPlayers(t *testing.T) {\n\tstore := StubPlayerStore{\n\t\tmap[string]int{\n\t\t\t\"Pepper\": 20,\n\t\t\t\"Floyd\":  10,\n\t\t},\n\t\tnil,\n\t\tnil,\n\t}\n\tserver := NewPlayerServer(&store)\n\n\tt.Run(\"returns Pepper's score\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Pepper\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\t\tassertResponseBody(t, response.Body.String(), \"20\")\n\t})\n\n\tt.Run(\"returns Floyd's score\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Floyd\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\t\tassertResponseBody(t, response.Body.String(), \"10\")\n\t})\n\n\tt.Run(\"returns 404 on missing players\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Apollo\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusNotFound)\n\t})\n}\n\nfunc TestStoreWins(t *testing.T) {\n\tstore := StubPlayerStore{\n\t\tmap[string]int{},\n\t\tnil,\n\t\tnil,\n\t}\n\tserver := NewPlayerServer(&store)\n\n\tt.Run(\"it records wins on POST\", func(t *testing.T) {\n\t\tplayer := \"Pepper\"\n\n\t\trequest := newPostWinRequest(player)\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response.Code, http.StatusAccepted)\n\n\t\tif len(store.winCalls) != 1 {\n\t\t\tt.Fatalf(\"got %d calls to RecordWin want %d\", len(store.winCalls), 1)\n\t\t}\n\n\t\tif store.winCalls[0] != player {\n\t\t\tt.Errorf(\"did not store the correct winner got %q want %q\", store.winCalls[0], player)\n\t\t}\n\t})\n}\n\nfunc TestLeague(t *testing.T) {\n\n\tt.Run(\"it returns the league table as JSON\", func(t *testing.T) {\n\t\twantedLeague := []Player{\n\t\t\t{\"Cleo\", 32},\n\t\t\t{\"Chris\", 20},\n\t\t\t{\"Tiest\", 14},\n\t\t}\n\n\t\tstore := StubPlayerStore{nil, nil, wantedLeague}\n\t\tserver := NewPlayerServer(&store)\n\n\t\trequest := newLeagueRequest()\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tgot := getLeagueFromResponse(t, response.Body)\n\n\t\tassertStatus(t, response.Code, http.StatusOK)\n\t\tassertLeague(t, got, wantedLeague)\n\t\tassertContentType(t, response, jsonContentType)\n\n\t})\n}\n\nfunc assertContentType(t testing.TB, response *httptest.ResponseRecorder, want string) {\n\tt.Helper()\n\tif response.Header().Get(\"content-type\") != want {\n\t\tt.Errorf(\"response did not have content-type of %s, got %v\", want, response.Result().Header)\n\t}\n}\n\nfunc getLeagueFromResponse(t testing.TB, body io.Reader) []Player {\n\tt.Helper()\n\tleague, err := NewLeague(body)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to parse response from server %q into slice of Player, '%v'\", body, err)\n\t}\n\n\treturn league\n}\n\nfunc assertLeague(t testing.TB, got, want []Player) {\n\tt.Helper()\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\nfunc assertStatus(t testing.TB, got, want int) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"did not get correct status, got %d, want %d\", got, want)\n\t}\n}\n\nfunc newLeagueRequest() *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, \"/league\", nil)\n\treturn req\n}\n\nfunc newGetScoreRequest(name string) *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, fmt.Sprintf(\"/players/%s\", name), nil)\n\treturn req\n}\n\nfunc newPostWinRequest(name string) *http.Request {\n\treq, _ := http.NewRequest(http.MethodPost, fmt.Sprintf(\"/players/%s\", name), nil)\n\treturn req\n}\n\nfunc assertResponseBody(t testing.TB, got, want string) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"response body is wrong, got %q want %q\", got, want)\n\t}\n}\n\npackage poker\n\nimport (\n\t\"io\"\n\t\"testing\"\n)\n\nfunc TestTape_Write(t *testing.T) {\n\tfile, clean := createTempFile(t, \"12345\")\n\tdefer clean()\n\n\ttape := &tape{file}\n\n\ttape.Write([]byte(\"abc\"))\n\n\tfile.Seek(0, io.SeekStart)\n\tnewFileContents, _ := io.ReadAll(file)\n\n\tgot := string(newFileContents)\n\twant := \"abc\"\n\n\tif got != want {\n\t\tt.Errorf(\"got %q want %q\", got, want)\n\t}\n}",
  "difficulty": "Fácil"
}
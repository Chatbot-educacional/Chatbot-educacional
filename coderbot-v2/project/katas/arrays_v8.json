{
  "title": "V8",
  "content": "Sum calculates the total from a slice of numbers.",
  "correct_code": "package main\n\nimport \"testing\"\n\nfunc AssertEqual[T comparable](t *testing.T, got, want T) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc AssertNotEqual[T comparable](t *testing.T, got, want T) {\n\tt.Helper()\n\tif got == want {\n\t\tt.Errorf(\"didn't want %v\", got)\n\t}\n}\n\nfunc AssertTrue(t *testing.T, got bool) {\n\tt.Helper()\n\tif !got {\n\t\tt.Errorf(\"got %v, want true\", got)\n\t}\n}\n\nfunc AssertFalse(t *testing.T, got bool) {\n\tt.Helper()\n\tif got {\n\t\tt.Errorf(\"got %v, want false\", got)\n\t}\n}\n\npackage main\n\ntype Transaction struct {\n\tFrom string\n\tTo   string\n\tSum  float64\n}\n\nfunc NewTransaction(from, to Account, sum float64) Transaction {\n\treturn Transaction{From: from.Name, To: to.Name, Sum: sum}\n}\n\ntype Account struct {\n\tName    string\n\tBalance float64\n}\n\nfunc NewBalanceFor(account Account, transactions []Transaction) Account {\n\treturn Reduce(\n\t\ttransactions,\n\t\tapplyTransaction,\n\t\taccount,\n\t)\n}\n\nfunc applyTransaction(a Account, transaction Transaction) Account {\n\tif transaction.From == a.Name {\n\t\ta.Balance -= transaction.Sum\n\t}\n\tif transaction.To == a.Name {\n\t\ta.Balance += transaction.Sum\n\t}\n\treturn a\n}\n\npackage main\n\nfunc Find[A any](items []A, predicate func(A) bool) (value A, found bool) {\n\tfor _, v := range items {\n\t\tif predicate(v) {\n\t\t\treturn v, true\n\t\t}\n\t}\n\treturn\n}\n\nfunc Reduce[A, B any](collection []A, f func(B, A) B, initialValue B) B {\n\tvar result = initialValue\n\tfor _, x := range collection {\n\t\tresult = f(result, x)\n\t}\n\treturn result\n}\n\npackage main\n\n// Sum calculates the total from a slice of numbers.\nfunc Sum(numbers []int) int {\n\tadd := func(acc, x int) int { return acc + x }\n\treturn Reduce(numbers, add, 0)\n}\n\n// SumAllTails calculates the sums of all but the first number given a collection of slices.\nfunc SumAllTails(numbers ...[]int) []int {\n\tsumTail := func(acc, x []int) []int {\n\t\tif len(x) == 0 {\n\t\t\treturn append(acc, 0)\n\t\t} else {\n\t\t\ttail := x[1:]\n\t\t\treturn append(acc, Sum(tail))\n\t\t}\n\t}\n\n\treturn Reduce(numbers, sumTail, []int{})\n}",
  "test_code": "package main\n\nimport \"testing\"\n\nfunc TestBadBank(t *testing.T) {\n\tvar (\n\t\triya  = Account{Name: \"Riya\", Balance: 100}\n\t\tchris = Account{Name: \"Chris\", Balance: 75}\n\t\tadil  = Account{Name: \"Adil\", Balance: 200}\n\n\t\ttransactions = []Transaction{\n\t\t\tNewTransaction(chris, riya, 100),\n\t\t\tNewTransaction(adil, chris, 25),\n\t\t}\n\t)\n\n\tnewBalanceFor := func(account Account) float64 {\n\t\treturn NewBalanceFor(account, transactions).Balance\n\t}\n\n\tAssertEqual(t, newBalanceFor(riya), 200)\n\tAssertEqual(t, newBalanceFor(chris), 0)\n\tAssertEqual(t, newBalanceFor(adil), 175)\n}\n\npackage main\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestSum(t *testing.T) {\n\n\tt.Run(\"collections of any size\", func(t *testing.T) {\n\n\t\tnumbers := []int{1, 2, 3}\n\n\t\tgot := Sum(numbers)\n\t\twant := 6\n\n\t\tif got != want {\n\t\t\tt.Errorf(\"got %d want %d given, %v\", got, want, numbers)\n\t\t}\n\t})\n\n}\n\nfunc TestSumAllTails(t *testing.T) {\n\n\tcheckSums := func(t *testing.T, got, want []int) {\n\t\tif !reflect.DeepEqual(got, want) {\n\t\t\tt.Errorf(\"got %v want %v\", got, want)\n\t\t}\n\t}\n\n\tt.Run(\"make the sums of tails of\", func(t *testing.T) {\n\t\tgot := SumAllTails([]int{1, 2}, []int{0, 9})\n\t\twant := []int{2, 9}\n\t\tcheckSums(t, got, want)\n\t})\n\n\tt.Run(\"safely sum empty slices\", func(t *testing.T) {\n\t\tgot := SumAllTails([]int{}, []int{3, 4, 5})\n\t\twant := []int{0, 9}\n\t\tcheckSums(t, got, want)\n\t})\n\n}\n\nfunc TestReduce(t *testing.T) {\n\tt.Run(\"multiplication of all elements\", func(t *testing.T) {\n\t\tmultiply := func(x, y int) int {\n\t\t\treturn x * y\n\t\t}\n\n\t\tAssertEqual(t, Reduce([]int{1, 2, 3}, multiply, 1), 6)\n\t})\n\n\tt.Run(\"concatenate strings\", func(t *testing.T) {\n\t\tconcatenate := func(x, y string) string {\n\t\t\treturn x + y\n\t\t}\n\n\t\tAssertEqual(t, Reduce([]string{\"a\", \"b\", \"c\"}, concatenate, \"\"), \"abc\")\n\t})\n}\n\nfunc TestFind(t *testing.T) {\n\tt.Run(\"find first even number\", func(t *testing.T) {\n\t\tnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n\t\tfirstEvenNumber, found := Find(numbers, func(x int) bool {\n\t\t\treturn x%2 == 0\n\t\t})\n\t\tAssertTrue(t, found)\n\t\tAssertEqual(t, firstEvenNumber, 2)\n\t})\n\n\ttype Person struct {\n\t\tName string\n\t}\n\n\tt.Run(\"Find the best programmer\", func(t *testing.T) {\n\t\tpeople := []Person{\n\t\t\tPerson{Name: \"Kent Beck\"},\n\t\t\tPerson{Name: \"Martin Fowler\"},\n\t\t\tPerson{Name: \"Chris James\"},\n\t\t}\n\n\t\tking, found := Find(people, func(p Person) bool {\n\t\t\treturn strings.Contains(p.Name, \"Chris\")\n\t\t})\n\n\t\tAssertTrue(t, found)\n\t\tAssertEqual(t, king, Person{Name: \"Chris James\"})\n\t})\n}",
  "difficulty": "Dif√≠cil"
}
{
  "title": "Clockface",
  "content": "A Point represents a two dimensional Cartesian coordinate.",
  "correct_code": "package clockface\n\nimport (\n\t\"math\"\n\t\"time\"\n)\n\n// A Point represents a two dimensional Cartesian coordinate.\ntype Point struct {\n\tX float64\n\tY float64\n}\n\nconst secondHandLength = 90\nconst clockCentreX = 150\nconst clockCentreY = 150\n\n// SecondHand is the unit vector of the second hand of an analogue clock at time `t`.\n// represented as a Point.\nfunc SecondHand(t time.Time) Point {\n\tp := secondHandPoint(t)\n\tp = Point{p.X * secondHandLength, p.Y * secondHandLength}\n\tp = Point{p.X, -p.Y}\n\tp = Point{p.X + clockCentreX, p.Y + clockCentreY} //translate\n\treturn p\n}\n\nfunc secondsInRadians(t time.Time) float64 {\n\treturn (math.Pi / (30 / (float64(t.Second()))))\n}\n\nfunc secondHandPoint(t time.Time) Point {\n\tangle := secondsInRadians(t)\n\tx := math.Sin(angle)\n\ty := math.Cos(angle)\n\n\treturn Point{x, y}\n}",
  "test_code": "package clockface_test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/quii/learn-go-with-tests/math/v6/clockface\"\n)\n\nfunc TestSecondHandAtMidnight(t *testing.T) {\n\ttm := time.Date(1337, time.January, 1, 0, 0, 0, 0, time.UTC)\n\n\twant := clockface.Point{X: 150, Y: 150 - 90}\n\tgot := clockface.SecondHand(tm)\n\n\tif got != want {\n\t\tt.Errorf(\"Got %v, wanted %v\", got, want)\n\t}\n}\n\nfunc TestSecondHandAt30Seconds(t *testing.T) {\n\ttm := time.Date(1337, time.January, 1, 0, 0, 30, 0, time.UTC)\n\n\twant := clockface.Point{X: 150, Y: 150 + 90}\n\tgot := clockface.SecondHand(tm)\n\n\tif got != want {\n\t\tt.Errorf(\"Got %v, wanted %v\", got, want)\n\t}\n}\n\npackage clockface\n\nimport (\n\t\"math\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSecondsInRadians(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tangle float64\n\t}{\n\t\t{simpleTime(0, 0, 30), math.Pi},\n\t\t{simpleTime(0, 0, 0), 0},\n\t\t{simpleTime(0, 0, 45), (math.Pi / 2) * 3},\n\t\t{simpleTime(0, 0, 7), (math.Pi / 30) * 7},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := secondsInRadians(c.time)\n\t\t\tif got != c.angle {\n\t\t\t\tt.Fatalf(\"Wanted %v radians, but got %v\", c.angle, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSecondHandPoint(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tpoint Point\n\t}{\n\t\t{simpleTime(0, 0, 30), Point{0, -1}},\n\t\t{simpleTime(0, 0, 45), Point{-1, 0}},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := secondHandPoint(c.time)\n\t\t\tif !roughlyEqualPoint(got, c.point) {\n\t\t\t\tt.Fatalf(\"Wanted %v Point, but got %v\", c.point, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc roughlyEqualFloat64(a, b float64) bool {\n\tconst equalityThreshold = 1e-7\n\treturn math.Abs(a-b) < equalityThreshold\n}\n\nfunc roughlyEqualPoint(a, b Point) bool {\n\treturn roughlyEqualFloat64(a.X, b.X) &&\n\t\troughlyEqualFloat64(a.Y, b.Y)\n}\n\nfunc simpleTime(hours, minutes, seconds int) time.Time {\n\treturn time.Date(312, time.October, 28, hours, minutes, seconds, 0, time.UTC)\n}\n\nfunc testName(t time.Time) string {\n\treturn t.Format(\"15:04:05\")\n}",
  "difficulty": "IntermediÃ¡rio"
}
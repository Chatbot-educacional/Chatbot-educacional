{
  "title": "Generics",
  "content": "",
  "correct_code": "package generics\n\nimport \"testing\"\n\nfunc AssertEqual[T comparable](t *testing.T, got, want T) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc AssertNotEqual[T comparable](t *testing.T, got, want T) {\n\tt.Helper()\n\tif got == want {\n\t\tt.Errorf(\"didn't want %v\", got)\n\t}\n}\n\nfunc AssertTrue(t *testing.T, got bool) {\n\tt.Helper()\n\tif !got {\n\t\tt.Errorf(\"got %v, want true\", got)\n\t}\n}\n\nfunc AssertFalse(t *testing.T, got bool) {\n\tt.Helper()\n\tif got {\n\t\tt.Errorf(\"got %v, want false\", got)\n\t}\n}\n\npackage generics\n\ntype Stack[T any] struct {\n\tvalues []T\n}\n\nfunc NewStack[T any]() *Stack[T] {\n\treturn new(Stack[T])\n}\n\nfunc (s *Stack[T]) Push(value T) {\n\ts.values = append(s.values, value)\n}\n\nfunc (s *Stack[T]) IsEmpty() bool {\n\treturn len(s.values) == 0\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n\tif s.IsEmpty() {\n\t\tvar zero T\n\t\treturn zero, false\n\t}\n\n\tindex := len(s.values) - 1\n\tel := s.values[index]\n\ts.values = s.values[:index]\n\treturn el, true\n}",
  "test_code": "package generics\n\nimport \"testing\"\n\nfunc TestAssertFunctions(t *testing.T) {\n\tt.Run(\"asserting on integers\", func(t *testing.T) {\n\t\tAssertEqual(t, 1, 1)\n\t\tAssertNotEqual(t, 1, 2)\n\t})\n\n\tt.Run(\"asserting on strings\", func(t *testing.T) {\n\t\tAssertEqual(t, \"hello\", \"hello\")\n\t\tAssertNotEqual(t, \"hello\", \"Grace\")\n\t})\n\n\t// AssertEqual(t, 1, \"1\") // uncomment to see the compilation error\n}\n\nfunc TestStack(t *testing.T) {\n\tt.Run(\"integer stack\", func(t *testing.T) {\n\t\tmyStackOfInts := NewStack[int]()\n\n\t\t// check stack is empty\n\t\tAssertTrue(t, myStackOfInts.IsEmpty())\n\n\t\t// add a thing, then check it's not empty\n\t\tmyStackOfInts.Push(123)\n\t\tAssertFalse(t, myStackOfInts.IsEmpty())\n\n\t\t// add another thing, pop it back again\n\t\tmyStackOfInts.Push(456)\n\t\tvalue, _ := myStackOfInts.Pop()\n\t\tAssertEqual(t, value, 456)\n\t\tvalue, _ = myStackOfInts.Pop()\n\t\tAssertEqual(t, value, 123)\n\t\tAssertTrue(t, myStackOfInts.IsEmpty())\n\n\t\t// can get the numbers we put in as numbers, not untyped interface{}\n\t\tmyStackOfInts.Push(1)\n\t\tmyStackOfInts.Push(2)\n\t\tfirstNum, _ := myStackOfInts.Pop()\n\t\tsecondNum, _ := myStackOfInts.Pop()\n\t\tAssertEqual(t, firstNum+secondNum, 3)\n\t})\n}",
  "difficulty": "Intermedi√°rio"
}
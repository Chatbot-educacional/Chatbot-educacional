{
  "title": "V3",
  "content": "Sleeper allows you to put delays.",
  "correct_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"time\"\n)\n\n// Sleeper allows you to put delays.\ntype Sleeper interface {\n\tSleep()\n}\n\n// DefaultSleeper is an implementation of Sleeper with a predefined delay.\ntype DefaultSleeper struct{}\n\n// Sleep will pause execution for the defined Duration.\nfunc (d *DefaultSleeper) Sleep() {\n\ttime.Sleep(1 * time.Second)\n}\n\nconst finalWord = \"Go!\"\nconst countdownStart = 3\n\n// Countdown prints a countdown from 3 to out with a delay between count provided by Sleeper.\nfunc Countdown(out io.Writer, sleeper Sleeper) {\n\tfor i := countdownStart; i > 0; i-- {\n\t\tfmt.Fprintln(out, i)\n\t\tsleeper.Sleep()\n\t}\n\n\tfmt.Fprint(out, finalWord)\n}\n\nfunc main() {\n\tsleeper := &DefaultSleeper{}\n\tCountdown(os.Stdout, sleeper)\n}",
  "test_code": "package main\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestCountdown(t *testing.T) {\n\tbuffer := &bytes.Buffer{}\n\tspySleeper := &SpySleeper{}\n\n\tCountdown(buffer, spySleeper)\n\n\tgot := buffer.String()\n\twant := `3\n2\n1\nGo!`\n\n\tif got != want {\n\t\tt.Errorf(\"got %q want %q\", got, want)\n\t}\n\n\tif spySleeper.Calls != 3 {\n\t\tt.Errorf(\"not enough calls to sleeper, want 3 got %d\", spySleeper.Calls)\n\t}\n}\n\ntype SpySleeper struct {\n\tCalls int\n}\n\nfunc (s *SpySleeper) Sleep() {\n\ts.Calls++\n}",
  "difficulty": "Intermedi√°rio"
}
{
  "title": "Clockface",
  "content": "A Point represents a two dimensional Cartesian coordinate.",
  "correct_code": "package clockface\n\nimport (\n\t\"math\"\n\t\"time\"\n)\n\n// A Point represents a two dimensional Cartesian coordinate.\ntype Point struct {\n\tX float64\n\tY float64\n}\n\nfunc secondsInRadians(t time.Time) float64 {\n\treturn (math.Pi / (30 / float64(t.Second())))\n}\n\nfunc secondHandPoint(t time.Time) Point {\n\tangle := secondsInRadians(t)\n\tx := math.Sin(angle)\n\ty := math.Cos(angle)\n\n\treturn Point{x, y}\n}\n\nfunc minutesInRadians(t time.Time) float64 {\n\treturn (secondsInRadians(t) / 60) +\n\t\t(math.Pi / (30 / float64(t.Minute())))\n}\n\npackage clockface\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n)\n\nconst (\n\tsecondHandLength = 90\n\tclockCentreX     = 150\n\tclockCentreY     = 150\n)\n\n// SVGWriter writes an SVG representation of an analogue clock, showing the time t, to the writer w.\nfunc SVGWriter(w io.Writer, t time.Time) {\n\tio.WriteString(w, svgStart)\n\tio.WriteString(w, bezel)\n\tsecondHand(w, t)\n\tio.WriteString(w, svgEnd)\n}\n\nfunc secondHand(w io.Writer, t time.Time) {\n\tp := secondHandPoint(t)\n\tp = Point{p.X * secondHandLength, p.Y * secondHandLength}\n\tp = Point{p.X, -p.Y}\n\tp = Point{p.X + clockCentreX, p.Y + clockCentreY} //translate\n\tfmt.Fprintf(w, `<line x1=\"150\" y1=\"150\" x2=\"%.3f\" y2=\"%.3f\" style=\"fill:none;stroke:#f00;stroke-width:3px;\"/>`, p.X, p.Y)\n}\n\nconst svgStart = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     width=\"100%\"\n     height=\"100%\"\n     viewBox=\"0 0 300 300\"\n     version=\"2.0\">`\n\nconst bezel = `<circle cx=\"150\" cy=\"150\" r=\"100\" style=\"fill:#fff;stroke:#000;stroke-width:5px;\"/>`\n\nconst svgEnd = `</svg>`",
  "test_code": "package clockface_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/quii/learn-go-with-tests/math/v8/clockface\"\n)\n\ntype SVG struct {\n\tXMLName xml.Name `xml:\"svg\"`\n\tText    string   `xml:\",chardata\"`\n\tXmlns   string   `xml:\"xmlns,attr\"`\n\tWidth   string   `xml:\"width,attr\"`\n\tHeight  string   `xml:\"height,attr\"`\n\tViewBox string   `xml:\"viewBox,attr\"`\n\tVersion string   `xml:\"version,attr\"`\n\tCircle  Circle   `xml:\"circle\"`\n\tLine    []Line   `xml:\"line\"`\n}\n\ntype Line struct {\n\tX1 float64 `xml:\"x1,attr\"`\n\tY1 float64 `xml:\"y1,attr\"`\n\tX2 float64 `xml:\"x2,attr\"`\n\tY2 float64 `xml:\"y2,attr\"`\n}\n\ntype Circle struct {\n\tCx float64 `xml:\"cx,attr\"`\n\tCy float64 `xml:\"cy,attr\"`\n\tR  float64 `xml:\"r,attr\"`\n}\n\nfunc TestSVGWriterSecondHand(t *testing.T) {\n\tcases := []struct {\n\t\ttime time.Time\n\t\tline Line\n\t}{\n\t\t{\n\t\t\tsimpleTime(0, 0, 0),\n\t\t\tLine{150, 150, 150, 60},\n\t\t},\n\t\t{\n\t\t\tsimpleTime(0, 0, 30),\n\t\t\tLine{150, 150, 150, 240},\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tb := bytes.Buffer{}\n\t\t\tclockface.SVGWriter(&b, c.time)\n\n\t\t\tsvg := SVG{}\n\t\t\txml.Unmarshal(b.Bytes(), &svg)\n\n\t\t\tif !containsLine(c.line, svg.Line) {\n\t\t\t\tt.Errorf(\"Expected to find the second hand line %+v, in the SVG lines %+v\", c.line, svg.Line)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSVGWriterMinuteHand(t *testing.T) {\n\tcases := []struct {\n\t\ttime time.Time\n\t\tline Line\n\t}{\n\t\t// {\n\t\t// \tsimpleTime(0, 0, 0),\n\t\t// \tLine{150, 150, 150, 70},\n\t\t// },\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tb := bytes.Buffer{}\n\t\t\tclockface.SVGWriter(&b, c.time)\n\n\t\t\tsvg := SVG{}\n\t\t\txml.Unmarshal(b.Bytes(), &svg)\n\n\t\t\tif !containsLine(c.line, svg.Line) {\n\t\t\t\tt.Errorf(\"Expected to find the minute hand line %+v, in the SVG lines %+v\", c.line, svg.Line)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc containsLine(l Line, ls []Line) bool {\n\tfor _, line := range ls {\n\t\tif line == l {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc simpleTime(hours, minutes, seconds int) time.Time {\n\treturn time.Date(312, time.October, 28, hours, minutes, seconds, 0, time.UTC)\n}\n\nfunc testName(t time.Time) string {\n\treturn t.Format(\"15:04:05\")\n}\n\npackage clockface\n\nimport (\n\t\"math\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSecondsInRadians(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tangle float64\n\t}{\n\t\t{simpleTime(0, 0, 30), math.Pi},\n\t\t{simpleTime(0, 0, 0), 0},\n\t\t{simpleTime(0, 0, 45), (math.Pi / 2) * 3},\n\t\t{simpleTime(0, 0, 7), (math.Pi / 30) * 7},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := secondsInRadians(c.time)\n\t\t\tif got != c.angle {\n\t\t\t\tt.Fatalf(\"Wanted %v radians, but got %v\", c.angle, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSecondHandPoint(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tpoint Point\n\t}{\n\t\t{simpleTime(0, 0, 30), Point{0, -1}},\n\t\t{simpleTime(0, 0, 45), Point{-1, 0}},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := secondHandPoint(c.time)\n\t\t\tif !roughlyEqualPoint(got, c.point) {\n\t\t\t\tt.Fatalf(\"Wanted %v Point, but got %v\", c.point, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMinutesInRadians(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tangle float64\n\t}{\n\t\t{simpleTime(0, 30, 0), math.Pi},\n\t\t{simpleTime(0, 0, 7), 7 * (math.Pi / (30 * 60))},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := minutesInRadians(c.time)\n\t\t\tif got != c.angle {\n\t\t\t\tt.Fatalf(\"Wanted %v radians, but got %v\", c.angle, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc roughlyEqualFloat64(a, b float64) bool {\n\tconst equalityThreshold = 1e-7\n\treturn math.Abs(a-b) < equalityThreshold\n}\n\nfunc roughlyEqualPoint(a, b Point) bool {\n\treturn roughlyEqualFloat64(a.X, b.X) &&\n\t\troughlyEqualFloat64(a.Y, b.Y)\n}\n\nfunc simpleTime(hours, minutes, seconds int) time.Time {\n\treturn time.Date(312, time.October, 28, hours, minutes, seconds, 0, time.UTC)\n}\n\nfunc testName(t time.Time) string {\n\treturn t.Format(\"15:04:05\")\n}",
  "difficulty": "IntermediÃ¡rio"
}
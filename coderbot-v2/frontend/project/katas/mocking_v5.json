{
  "title": "V5",
  "content": "Sleeper allows you to put delays.",
  "correct_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"time\"\n)\n\n// Sleeper allows you to put delays.\ntype Sleeper interface {\n\tSleep()\n}\n\n// ConfigurableSleeper is an implementation of Sleeper with a defined delay.\ntype ConfigurableSleeper struct {\n\tduration time.Duration\n\tsleep    func(time.Duration)\n}\n\n// Sleep will pause execution for the defined Duration.\nfunc (c *ConfigurableSleeper) Sleep() {\n\tc.sleep(c.duration)\n}\n\nconst finalWord = \"Go!\"\nconst countdownStart = 3\n\n// Countdown prints a countdown from 3 to out with a delay between count provided by Sleeper.\nfunc Countdown(out io.Writer, sleeper Sleeper) {\n\n\tfor i := countdownStart; i > 0; i-- {\n\t\tfmt.Fprintln(out, i)\n\t\tsleeper.Sleep()\n\t}\n\n\tfmt.Fprint(out, finalWord)\n}\n\nfunc main() {\n\tsleeper := &ConfigurableSleeper{1 * time.Second, time.Sleep}\n\tCountdown(os.Stdout, sleeper)\n}",
  "test_code": "package main\n\nimport (\n\t\"bytes\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestCountdown(t *testing.T) {\n\n\tt.Run(\"prints 3 to Go!\", func(t *testing.T) {\n\t\tbuffer := &bytes.Buffer{}\n\t\tCountdown(buffer, &SpyCountdownOperations{})\n\n\t\tgot := buffer.String()\n\t\twant := `3\n2\n1\nGo!`\n\n\t\tif got != want {\n\t\t\tt.Errorf(\"got %q want %q\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"sleep before every print\", func(t *testing.T) {\n\t\tspySleepPrinter := &SpyCountdownOperations{}\n\t\tCountdown(spySleepPrinter, spySleepPrinter)\n\n\t\twant := []string{\n\t\t\twrite,\n\t\t\tsleep,\n\t\t\twrite,\n\t\t\tsleep,\n\t\t\twrite,\n\t\t\tsleep,\n\t\t\twrite,\n\t\t}\n\n\t\tif !reflect.DeepEqual(want, spySleepPrinter.Calls) {\n\t\t\tt.Errorf(\"wanted calls %v got %v\", want, spySleepPrinter.Calls)\n\t\t}\n\t})\n}\n\nfunc TestConfigurableSleeper(t *testing.T) {\n\tsleepTime := 5 * time.Second\n\n\tspyTime := &SpyTime{}\n\tsleeper := ConfigurableSleeper{sleepTime, spyTime.Sleep}\n\tsleeper.Sleep()\n\n\tif spyTime.durationSlept != sleepTime {\n\t\tt.Errorf(\"should have slept for %v but slept for %v\", sleepTime, spyTime.durationSlept)\n\t}\n}\n\ntype SpyCountdownOperations struct {\n\tCalls []string\n}\n\nfunc (s *SpyCountdownOperations) Sleep() {\n\ts.Calls = append(s.Calls, sleep)\n}\n\nfunc (s *SpyCountdownOperations) Write(p []byte) (n int, err error) {\n\ts.Calls = append(s.Calls, write)\n\treturn\n}\n\nconst write = \"write\"\nconst sleep = \"sleep\"\n\ntype SpyTime struct {\n\tdurationSlept time.Duration\n}\n\nfunc (s *SpyTime) Sleep(duration time.Duration) {\n\ts.durationSlept = duration\n}",
  "difficulty": "Dif√≠cil"
}
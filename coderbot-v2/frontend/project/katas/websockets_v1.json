{
  "title": "V1",
  "content": "BlindAlerter schedules alerts for blind amounts.",
  "correct_code": "package poker\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n)\n\n// BlindAlerter schedules alerts for blind amounts.\ntype BlindAlerter interface {\n\tScheduleAlertAt(duration time.Duration, amount int)\n}\n\n// BlindAlerterFunc allows you to implement BlindAlerter with a function.\ntype BlindAlerterFunc func(duration time.Duration, amount int)\n\n// ScheduleAlertAt is BlindAlerterFunc implementation of BlindAlerter.\nfunc (a BlindAlerterFunc) ScheduleAlertAt(duration time.Duration, amount int) {\n\ta(duration, amount)\n}\n\n// StdOutAlerter will schedule alerts and print them to os.Stdout.\nfunc StdOutAlerter(duration time.Duration, amount int) {\n\ttime.AfterFunc(duration, func() {\n\t\tfmt.Fprintf(os.Stdout, \"Blind is now %d\\n\", amount)\n\t})\n}\n\npackage poker\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CLI helps players through a game of poker.\ntype CLI struct {\n\tplayerStore PlayerStore\n\tin          *bufio.Scanner\n\tout         io.Writer\n\tgame        Game\n}\n\n// NewCLI creates a CLI for playing poker.\nfunc NewCLI(in io.Reader, out io.Writer, game Game) *CLI {\n\treturn &CLI{\n\t\tin:   bufio.NewScanner(in),\n\t\tout:  out,\n\t\tgame: game,\n\t}\n}\n\n// PlayerPrompt is the text asking the user for the number of players.\nconst PlayerPrompt = \"Please enter the number of players: \"\n\n// BadPlayerInputErrMsg is the text telling the user they did bad things.\nconst BadPlayerInputErrMsg = \"Bad value received for number of players, please try again with a number\"\n\n// BadWinnerInputMsg is the text telling the user they declared the winner wrong.\nconst BadWinnerInputMsg = \"invalid winner input, expect format of 'PlayerName wins'\"\n\n// PlayPoker starts the game.\nfunc (cli *CLI) PlayPoker() {\n\tfmt.Fprint(cli.out, PlayerPrompt)\n\n\tnumberOfPlayers, err := strconv.Atoi(cli.readLine())\n\n\tif err != nil {\n\t\tfmt.Fprint(cli.out, BadPlayerInputErrMsg)\n\t\treturn\n\t}\n\n\tcli.game.Start(numberOfPlayers)\n\n\twinnerInput := cli.readLine()\n\twinner, err := extractWinner(winnerInput)\n\n\tif err != nil {\n\t\tfmt.Fprint(cli.out, BadWinnerInputMsg)\n\t\treturn\n\t}\n\n\tcli.game.Finish(winner)\n}\n\nfunc extractWinner(userInput string) (string, error) {\n\tif !strings.Contains(userInput, \" wins\") {\n\t\treturn \"\", errors.New(BadWinnerInputMsg)\n\t}\n\treturn strings.Replace(userInput, \" wins\", \"\", 1), nil\n}\n\nfunc (cli *CLI) readLine() string {\n\tcli.in.Scan()\n\treturn cli.in.Text()\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sort\"\n)\n\n// FileSystemPlayerStore stores players in the filesystem.\ntype FileSystemPlayerStore struct {\n\tdatabase *json.Encoder\n\tleague   League\n}\n\n// NewFileSystemPlayerStore creates a FileSystemPlayerStore initialising the store if needed.\nfunc NewFileSystemPlayerStore(file *os.File) (*FileSystemPlayerStore, error) {\n\n\terr := initialisePlayerDBFile(file)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"problem initialising player db file, %v\", err)\n\t}\n\n\tleague, err := NewLeague(file)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"problem loading player store from file %s, %v\", file.Name(), err)\n\t}\n\n\treturn &FileSystemPlayerStore{\n\t\tdatabase: json.NewEncoder(&tape{file}),\n\t\tleague:   league,\n\t}, nil\n}\n\n// FileSystemPlayerStoreFromFile creates a PlayerStore from the contents of a JSON file found at path.\nfunc FileSystemPlayerStoreFromFile(path string) (*FileSystemPlayerStore, func(), error) {\n\tdb, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE, 0666)\n\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"problem opening %s %v\", path, err)\n\t}\n\n\tcloseFunc := func() {\n\t\tdb.Close()\n\t}\n\n\tstore, err := NewFileSystemPlayerStore(db)\n\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"problem creating file system player store, %v \", err)\n\t}\n\n\treturn store, closeFunc, nil\n}\n\nfunc initialisePlayerDBFile(file *os.File) error {\n\tfile.Seek(0, io.SeekStart)\n\n\tinfo, err := file.Stat()\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"problem getting file info from file %s, %v\", file.Name(), err)\n\t}\n\n\tif info.Size() == 0 {\n\t\tfile.Write([]byte(\"[]\"))\n\t\tfile.Seek(0, io.SeekStart)\n\t}\n\n\treturn nil\n}\n\n// GetLeague returns the Scores of all the players.\nfunc (f *FileSystemPlayerStore) GetLeague() League {\n\tsort.Slice(f.league, func(i, j int) bool {\n\t\treturn f.league[i].Wins > f.league[j].Wins\n\t})\n\treturn f.league\n}\n\n// GetPlayerScore retrieves a player's score.\nfunc (f *FileSystemPlayerStore) GetPlayerScore(name string) int {\n\n\tplayer := f.league.Find(name)\n\n\tif player != nil {\n\t\treturn player.Wins\n\t}\n\n\treturn 0\n}\n\n// RecordWin will store a win for a player, incrementing wins if already known.\nfunc (f *FileSystemPlayerStore) RecordWin(name string) {\n\tplayer := f.league.Find(name)\n\n\tif player != nil {\n\t\tplayer.Wins++\n\t} else {\n\t\tf.league = append(f.league, Player{name, 1})\n\t}\n\n\tf.database.Encode(f.league)\n}\n\npackage poker\n\n// Game manages the state of a game.\ntype Game interface {\n\tStart(numberOfPlayers int)\n\tFinish(winner string)\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n)\n\n// League stores a collection of players.\ntype League []Player\n\n// Find tries to return a player from a League.\nfunc (l League) Find(name string) *Player {\n\tfor i, p := range l {\n\t\tif p.Name == name {\n\t\t\treturn &l[i]\n\t\t}\n\t}\n\treturn nil\n}\n\n// NewLeague creates a League from JSON.\nfunc NewLeague(rdr io.Reader) (League, error) {\n\tvar league []Player\n\terr := json.NewDecoder(rdr).Decode(&league)\n\n\tif err != nil {\n\t\terr = fmt.Errorf(\"problem parsing League, %v\", err)\n\t}\n\n\treturn league, err\n}\n\npackage poker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// PlayerStore stores score information about players.\ntype PlayerStore interface {\n\tGetPlayerScore(name string) int\n\tRecordWin(name string)\n\tGetLeague() League\n}\n\n// Player stores a name with a number of wins.\ntype Player struct {\n\tName string\n\tWins int\n}\n\n// PlayerServer is a HTTP interface for player information.\ntype PlayerServer struct {\n\tstore PlayerStore\n\thttp.Handler\n\ttemplate *template.Template\n}\n\nconst jsonContentType = \"application/json\"\nconst htmlTemplatePath = \"game.html\"\n\n// NewPlayerServer creates a PlayerServer with routing configured.\nfunc NewPlayerServer(store PlayerStore) (*PlayerServer, error) {\n\tp := new(PlayerServer)\n\n\ttmpl, err := template.ParseFiles(htmlTemplatePath)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"problem opening %s %v\", htmlTemplatePath, err)\n\t}\n\n\tp.template = tmpl\n\tp.store = store\n\n\trouter := http.NewServeMux()\n\trouter.Handle(\"/league\", http.HandlerFunc(p.leagueHandler))\n\trouter.Handle(\"/players/\", http.HandlerFunc(p.playersHandler))\n\trouter.Handle(\"/game\", http.HandlerFunc(p.game))\n\trouter.Handle(\"/ws\", http.HandlerFunc(p.webSocket))\n\n\tp.Handler = router\n\n\treturn p, nil\n}\n\nvar wsUpgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nfunc (p *PlayerServer) webSocket(w http.ResponseWriter, r *http.Request) {\n\tconn, _ := wsUpgrader.Upgrade(w, r, nil)\n\t_, winnerMsg, _ := conn.ReadMessage()\n\tp.store.RecordWin(string(winnerMsg))\n}\n\nfunc (p *PlayerServer) game(w http.ResponseWriter, r *http.Request) {\n\tp.template.Execute(w, nil)\n}\n\nfunc (p *PlayerServer) leagueHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", jsonContentType)\n\tjson.NewEncoder(w).Encode(p.store.GetLeague())\n}\n\nfunc (p *PlayerServer) playersHandler(w http.ResponseWriter, r *http.Request) {\n\tplayer := strings.TrimPrefix(r.URL.Path, \"/players/\")\n\n\tswitch r.Method {\n\tcase http.MethodPost:\n\t\tp.processWin(w, player)\n\tcase http.MethodGet:\n\t\tp.showScore(w, player)\n\t}\n}\n\nfunc (p *PlayerServer) showScore(w http.ResponseWriter, player string) {\n\tscore := p.store.GetPlayerScore(player)\n\n\tif score == 0 {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t}\n\n\tfmt.Fprint(w, score)\n}\n\nfunc (p *PlayerServer) processWin(w http.ResponseWriter, player string) {\n\tp.store.RecordWin(player)\n\tw.WriteHeader(http.StatusAccepted)\n}\n\npackage poker\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\ntype tape struct {\n\tfile *os.File\n}\n\nfunc (t *tape) Write(p []byte) (n int, err error) {\n\tt.file.Truncate(0)\n\tt.file.Seek(0, io.SeekStart)\n\treturn t.file.Write(p)\n}\n\npackage poker\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\n// StubPlayerStore implements PlayerStore for testing purposes.\ntype StubPlayerStore struct {\n\tScores   map[string]int\n\tWinCalls []string\n\tLeague   []Player\n}\n\n// GetPlayerScore returns a score from Scores.\nfunc (s *StubPlayerStore) GetPlayerScore(name string) int {\n\tscore := s.Scores[name]\n\treturn score\n}\n\n// RecordWin will record a win to WinCalls.\nfunc (s *StubPlayerStore) RecordWin(name string) {\n\ts.WinCalls = append(s.WinCalls, name)\n}\n\n// GetLeague returns League.\nfunc (s *StubPlayerStore) GetLeague() League {\n\treturn s.League\n}\n\n// AssertPlayerWin allows you to spy on the store's calls to RecordWin.\nfunc AssertPlayerWin(t testing.TB, store *StubPlayerStore, winner string) {\n\tt.Helper()\n\n\tif len(store.WinCalls) != 1 {\n\t\tt.Fatalf(\"got %d calls to RecordWin want %d\", len(store.WinCalls), 1)\n\t}\n\n\tif store.WinCalls[0] != winner {\n\t\tt.Errorf(\"did not store correct winner got %q want %q\", store.WinCalls[0], winner)\n\t}\n}\n\n// ScheduledAlert holds information about when an alert is scheduled.\ntype ScheduledAlert struct {\n\tAt     time.Duration\n\tAmount int\n}\n\nfunc (s ScheduledAlert) String() string {\n\treturn fmt.Sprintf(\"%d chips at %v\", s.Amount, s.At)\n}\n\n// SpyBlindAlerter allows you to spy on ScheduleAlertAt calls.\ntype SpyBlindAlerter struct {\n\tAlerts []ScheduledAlert\n}\n\n// ScheduleAlertAt records alerts that have been scheduled.\nfunc (s *SpyBlindAlerter) ScheduleAlertAt(at time.Duration, amount int) {\n\ts.Alerts = append(s.Alerts, ScheduledAlert{at, amount})\n}\n\npackage poker\n\nimport \"time\"\n\n// TexasHoldem manages a game of poker.\ntype TexasHoldem struct {\n\talerter BlindAlerter\n\tstore   PlayerStore\n}\n\n// NewTexasHoldem returns a new game.\nfunc NewTexasHoldem(alerter BlindAlerter, store PlayerStore) *TexasHoldem {\n\treturn &TexasHoldem{\n\t\talerter: alerter,\n\t\tstore:   store,\n\t}\n}\n\n// Start will schedule blind alerts dependant on the number of players.\nfunc (p *TexasHoldem) Start(numberOfPlayers int) {\n\tblindIncrement := time.Duration(5+numberOfPlayers) * time.Minute\n\n\tblinds := []int{100, 200, 300, 400, 500, 600, 800, 1000, 2000, 4000, 8000}\n\tblindTime := 0 * time.Second\n\tfor _, blind := range blinds {\n\t\tp.alerter.ScheduleAlertAt(blindTime, blind)\n\t\tblindTime = blindTime + blindIncrement\n\t}\n}\n\n// Finish ends the game, recording the winner.\nfunc (p *TexasHoldem) Finish(winner string) {\n\tp.store.RecordWin(winner)\n}",
  "test_code": "package poker_test\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n\n\tpoker \"github.com/quii/learn-go-with-tests/websockets/v1\"\n)\n\nvar dummyBlindAlerter = &poker.SpyBlindAlerter{}\nvar dummyPlayerStore = &poker.StubPlayerStore{}\nvar dummyStdIn = &bytes.Buffer{}\nvar dummyStdOut = &bytes.Buffer{}\n\ntype GameSpy struct {\n\tStartCalled     bool\n\tStartCalledWith int\n\n\tFinishedCalled   bool\n\tFinishCalledWith string\n}\n\nfunc (g *GameSpy) Start(numberOfPlayers int) {\n\tg.StartCalled = true\n\tg.StartCalledWith = numberOfPlayers\n}\n\nfunc (g *GameSpy) Finish(winner string) {\n\tg.FinishedCalled = true\n\tg.FinishCalledWith = winner\n}\n\nfunc userSends(messages ...string) io.Reader {\n\treturn strings.NewReader(strings.Join(messages, \"\\n\"))\n}\n\nfunc TestCLI(t *testing.T) {\n\n\tt.Run(\"start game with 3 players and finish game with 'Chris' as winner\", func(t *testing.T) {\n\t\tgame := &GameSpy{}\n\t\tstdout := &bytes.Buffer{}\n\n\t\tin := userSends(\"3\", \"Chris wins\")\n\t\tcli := poker.NewCLI(in, stdout, game)\n\n\t\tcli.PlayPoker()\n\n\t\tassertMessagesSentToUser(t, stdout, poker.PlayerPrompt)\n\t\tassertGameStartedWith(t, game, 3)\n\t\tassertFinishCalledWith(t, game, \"Chris\")\n\t})\n\n\tt.Run(\"start game with 8 players and record 'Cleo' as winner\", func(t *testing.T) {\n\t\tgame := &GameSpy{}\n\n\t\tin := userSends(\"8\", \"Cleo wins\")\n\t\tcli := poker.NewCLI(in, dummyStdOut, game)\n\n\t\tcli.PlayPoker()\n\n\t\tassertGameStartedWith(t, game, 8)\n\t\tassertFinishCalledWith(t, game, \"Cleo\")\n\t})\n\n\tt.Run(\"it prints an error when a non numeric value is entered and does not start the game\", func(t *testing.T) {\n\t\tgame := &GameSpy{}\n\n\t\tstdout := &bytes.Buffer{}\n\t\tin := userSends(\"pies\")\n\n\t\tcli := poker.NewCLI(in, stdout, game)\n\t\tcli.PlayPoker()\n\n\t\tassertGameNotStarted(t, game)\n\t\tassertMessagesSentToUser(t, stdout, poker.PlayerPrompt, poker.BadPlayerInputErrMsg)\n\t})\n\n\tt.Run(\"it prints an error when the winner is declared incorrectly\", func(t *testing.T) {\n\t\tgame := &GameSpy{}\n\t\tstdout := &bytes.Buffer{}\n\n\t\tin := userSends(\"8\", \"Lloyd is a killer\")\n\t\tcli := poker.NewCLI(in, stdout, game)\n\n\t\tcli.PlayPoker()\n\n\t\tassertGameNotFinished(t, game)\n\t\tassertMessagesSentToUser(t, stdout, poker.PlayerPrompt, poker.BadWinnerInputMsg)\n\t})\n}\n\nfunc assertGameStartedWith(t testing.TB, game *GameSpy, numberOfPlayersWanted int) {\n\tt.Helper()\n\tif game.StartCalledWith != numberOfPlayersWanted {\n\t\tt.Errorf(\"wanted Start called with %d but got %d\", numberOfPlayersWanted, game.StartCalledWith)\n\t}\n}\n\nfunc assertGameNotFinished(t testing.TB, game *GameSpy) {\n\tt.Helper()\n\tif game.FinishedCalled {\n\t\tt.Errorf(\"game should not have finished\")\n\t}\n}\n\nfunc assertGameNotStarted(t testing.TB, game *GameSpy) {\n\tt.Helper()\n\tif game.StartCalled {\n\t\tt.Errorf(\"game should not have started\")\n\t}\n}\n\nfunc assertFinishCalledWith(t testing.TB, game *GameSpy, winner string) {\n\tt.Helper()\n\tif game.FinishCalledWith != winner {\n\t\tt.Errorf(\"expected finish called with %q but got %q\", winner, game.FinishCalledWith)\n\t}\n}\n\nfunc assertMessagesSentToUser(t testing.TB, stdout *bytes.Buffer, messages ...string) {\n\tt.Helper()\n\twant := strings.Join(messages, \"\")\n\tgot := stdout.String()\n\tif got != want {\n\t\tt.Errorf(\"got %q sent to stdout but expected %+v\", got, messages)\n\t}\n}\n\nfunc assertScheduledAlert(t testing.TB, got, want poker.ScheduledAlert) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"got %+v, want %+v\", got, want)\n\t}\n}\n\npackage poker\n\nimport (\n\t\"os\"\n\t\"testing\"\n)\n\nfunc createTempFile(t testing.TB, initialData string) (*os.File, func()) {\n\tt.Helper()\n\n\ttmpfile, err := os.CreateTemp(\"\", \"db\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"could not create temp file %v\", err)\n\t}\n\n\ttmpfile.Write([]byte(initialData))\n\n\tremoveFile := func() {\n\t\ttmpfile.Close()\n\t\tos.Remove(tmpfile.Name())\n\t}\n\n\treturn tmpfile, removeFile\n}\n\nfunc TestFileSystemStore(t *testing.T) {\n\n\tt.Run(\"League sorted\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tgot := store.GetLeague()\n\n\t\twant := []Player{\n\t\t\t{\"Chris\", 33},\n\t\t\t{\"Cleo\", 10},\n\t\t}\n\n\t\tassertLeague(t, got, want)\n\n\t\t// read again\n\t\tgot = store.GetLeague()\n\t\tassertLeague(t, got, want)\n\t})\n\n\tt.Run(\"get player score\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tgot := store.GetPlayerScore(\"Chris\")\n\t\twant := 33\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"store wins for existing players\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tstore.RecordWin(\"Chris\")\n\n\t\tgot := store.GetPlayerScore(\"Chris\")\n\t\twant := 34\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"store wins for existing players\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, `[\n\t\t\t{\"Name\": \"Cleo\", \"Wins\": 10},\n\t\t\t{\"Name\": \"Chris\", \"Wins\": 33}]`)\n\t\tdefer cleanDatabase()\n\n\t\tstore, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\n\t\tstore.RecordWin(\"Pepper\")\n\n\t\tgot := store.GetPlayerScore(\"Pepper\")\n\t\twant := 1\n\t\tassertScoreEquals(t, got, want)\n\t})\n\n\tt.Run(\"works with an empty file\", func(t *testing.T) {\n\t\tdatabase, cleanDatabase := createTempFile(t, \"\")\n\t\tdefer cleanDatabase()\n\n\t\t_, err := NewFileSystemPlayerStore(database)\n\n\t\tassertNoError(t, err)\n\t})\n}\n\nfunc assertScoreEquals(t testing.TB, got, want int) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"got %d want %d\", got, want)\n\t}\n}\n\nfunc assertNoError(t testing.TB, err error) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatalf(\"didn't expect an error but got one, %v\", err)\n\t}\n}\n\npackage poker\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc TestRecordingWinsAndRetrievingThem(t *testing.T) {\n\tdatabase, cleanDatabase := createTempFile(t, `[]`)\n\tdefer cleanDatabase()\n\tstore, err := NewFileSystemPlayerStore(database)\n\n\tassertNoError(t, err)\n\n\tserver := mustMakePlayerServer(t, store)\n\tplayer := \"Pepper\"\n\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\tserver.ServeHTTP(httptest.NewRecorder(), newPostWinRequest(player))\n\n\tt.Run(\"get score\", func(t *testing.T) {\n\t\tresponse := httptest.NewRecorder()\n\t\tserver.ServeHTTP(response, newGetScoreRequest(player))\n\t\tassertStatus(t, response, http.StatusOK)\n\n\t\tassertResponseBody(t, response.Body.String(), \"3\")\n\t})\n\n\tt.Run(\"get League\", func(t *testing.T) {\n\t\tresponse := httptest.NewRecorder()\n\t\tserver.ServeHTTP(response, newLeagueRequest())\n\t\tassertStatus(t, response, http.StatusOK)\n\n\t\tgot := getLeagueFromResponse(t, response.Body)\n\t\twant := []Player{\n\t\t\t{\"Pepper\", 3},\n\t\t}\n\t\tassertLeague(t, got, want)\n\t})\n}\n\npackage poker\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc mustMakePlayerServer(t *testing.T, store PlayerStore) *PlayerServer {\n\tserver, err := NewPlayerServer(store)\n\tif err != nil {\n\t\tt.Fatal(\"problem creating player server\", err)\n\t}\n\treturn server\n}\n\nfunc TestGETPlayers(t *testing.T) {\n\tstore := StubPlayerStore{\n\t\tmap[string]int{\n\t\t\t\"Pepper\": 20,\n\t\t\t\"Floyd\":  10,\n\t\t},\n\t\tnil,\n\t\tnil,\n\t}\n\tserver := mustMakePlayerServer(t, &store)\n\n\tt.Run(\"returns Pepper's score\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Pepper\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response, http.StatusOK)\n\t\tassertResponseBody(t, response.Body.String(), \"20\")\n\t})\n\n\tt.Run(\"returns Floyd's score\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Floyd\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response, http.StatusOK)\n\t\tassertResponseBody(t, response.Body.String(), \"10\")\n\t})\n\n\tt.Run(\"returns 404 on missing players\", func(t *testing.T) {\n\t\trequest := newGetScoreRequest(\"Apollo\")\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response, http.StatusNotFound)\n\t})\n}\n\nfunc TestStoreWins(t *testing.T) {\n\tstore := StubPlayerStore{\n\t\tmap[string]int{},\n\t\tnil,\n\t\tnil,\n\t}\n\tserver := mustMakePlayerServer(t, &store)\n\n\tt.Run(\"it records wins on POST\", func(t *testing.T) {\n\t\tplayer := \"Pepper\"\n\n\t\trequest := newPostWinRequest(player)\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response, http.StatusAccepted)\n\t\tAssertPlayerWin(t, &store, player)\n\t})\n}\n\nfunc TestLeague(t *testing.T) {\n\n\tt.Run(\"it returns the League table as JSON\", func(t *testing.T) {\n\t\twantedLeague := []Player{\n\t\t\t{\"Cleo\", 32},\n\t\t\t{\"Chris\", 20},\n\t\t\t{\"Tiest\", 14},\n\t\t}\n\n\t\tstore := StubPlayerStore{nil, nil, wantedLeague}\n\t\tserver := mustMakePlayerServer(t, &store)\n\n\t\trequest := newLeagueRequest()\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tgot := getLeagueFromResponse(t, response.Body)\n\n\t\tassertStatus(t, response, http.StatusOK)\n\t\tassertLeague(t, got, wantedLeague)\n\t\tassertContentType(t, response, jsonContentType)\n\n\t})\n}\n\nfunc TestGame(t *testing.T) {\n\tt.Run(\"GET /game returns 200\", func(t *testing.T) {\n\t\tserver := mustMakePlayerServer(t, &StubPlayerStore{})\n\n\t\trequest := newGameRequest()\n\t\tresponse := httptest.NewRecorder()\n\n\t\tserver.ServeHTTP(response, request)\n\n\t\tassertStatus(t, response, http.StatusOK)\n\t})\n\n\tt.Run(\"when we get a message over a websocket it is a winner of a game\", func(t *testing.T) {\n\t\tstore := &StubPlayerStore{}\n\t\twinner := \"Ruth\"\n\t\tserver := httptest.NewServer(mustMakePlayerServer(t, store))\n\t\tdefer server.Close()\n\n\t\twsURL := \"ws\" + strings.TrimPrefix(server.URL, \"http\") + \"/ws\"\n\n\t\tws, _, err := websocket.DefaultDialer.Dial(wsURL, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not open a ws connection on %s %v\", wsURL, err)\n\t\t}\n\t\tdefer ws.Close()\n\n\t\twriteWSMessage(t, ws, winner)\n\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tAssertPlayerWin(t, store, winner)\n\t})\n}\n\nfunc writeWSMessage(t testing.TB, conn *websocket.Conn, message string) {\n\tt.Helper()\n\tif err := conn.WriteMessage(websocket.TextMessage, []byte(message)); err != nil {\n\t\tt.Fatalf(\"could not send message over ws connection %v\", err)\n\t}\n}\n\nfunc assertContentType(t testing.TB, response *httptest.ResponseRecorder, want string) {\n\tt.Helper()\n\tif response.Header().Get(\"content-type\") != want {\n\t\tt.Errorf(\"response did not have content-type of %s, got %v\", want, response.Result().Header)\n\t}\n}\n\nfunc getLeagueFromResponse(t testing.TB, body io.Reader) []Player {\n\tt.Helper()\n\tleague, err := NewLeague(body)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to parse response from server %q into slice of Player, '%v'\", body, err)\n\t}\n\n\treturn league\n}\n\nfunc assertLeague(t testing.TB, got, want []Player) {\n\tt.Helper()\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\nfunc assertStatus(t testing.TB, got *httptest.ResponseRecorder, want int) {\n\tt.Helper()\n\tif got.Code != want {\n\t\tt.Errorf(\"did not get correct status, got %d, want %d\", got.Code, want)\n\t}\n}\n\nfunc newGameRequest() *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, \"/game\", nil)\n\treturn req\n}\n\nfunc newLeagueRequest() *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, \"/league\", nil)\n\treturn req\n}\n\nfunc newGetScoreRequest(name string) *http.Request {\n\treq, _ := http.NewRequest(http.MethodGet, fmt.Sprintf(\"/players/%s\", name), nil)\n\treturn req\n}\n\nfunc newPostWinRequest(name string) *http.Request {\n\treq, _ := http.NewRequest(http.MethodPost, fmt.Sprintf(\"/players/%s\", name), nil)\n\treturn req\n}\n\nfunc assertResponseBody(t testing.TB, got, want string) {\n\tt.Helper()\n\tif got != want {\n\t\tt.Errorf(\"response body is wrong, got %q want %q\", got, want)\n\t}\n}\n\npackage poker\n\nimport (\n\t\"io\"\n\t\"testing\"\n)\n\nfunc TestTape_Write(t *testing.T) {\n\tfile, clean := createTempFile(t, \"12345\")\n\tdefer clean()\n\n\ttape := &tape{file}\n\n\ttape.Write([]byte(\"abc\"))\n\n\tfile.Seek(0, io.SeekStart)\n\tnewFileContents, _ := io.ReadAll(file)\n\n\tgot := string(newFileContents)\n\twant := \"abc\"\n\n\tif got != want {\n\t\tt.Errorf(\"got %q want %q\", got, want)\n\t}\n}\n\npackage poker_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/quii/learn-go-with-tests/websockets/v1\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestGame_Start(t *testing.T) {\n\tt.Run(\"schedules alerts on game start for 5 players\", func(t *testing.T) {\n\t\tblindAlerter := &poker.SpyBlindAlerter{}\n\t\tgame := poker.NewTexasHoldem(blindAlerter, dummyPlayerStore)\n\n\t\tgame.Start(5)\n\n\t\tcases := []poker.ScheduledAlert{\n\t\t\t{At: 0 * time.Second, Amount: 100},\n\t\t\t{At: 10 * time.Minute, Amount: 200},\n\t\t\t{At: 20 * time.Minute, Amount: 300},\n\t\t\t{At: 30 * time.Minute, Amount: 400},\n\t\t\t{At: 40 * time.Minute, Amount: 500},\n\t\t\t{At: 50 * time.Minute, Amount: 600},\n\t\t\t{At: 60 * time.Minute, Amount: 800},\n\t\t\t{At: 70 * time.Minute, Amount: 1000},\n\t\t\t{At: 80 * time.Minute, Amount: 2000},\n\t\t\t{At: 90 * time.Minute, Amount: 4000},\n\t\t\t{At: 100 * time.Minute, Amount: 8000},\n\t\t}\n\n\t\tcheckSchedulingCases(cases, t, blindAlerter)\n\t})\n\n\tt.Run(\"schedules alerts on game start for 7 players\", func(t *testing.T) {\n\t\tblindAlerter := &poker.SpyBlindAlerter{}\n\t\tgame := poker.NewTexasHoldem(blindAlerter, dummyPlayerStore)\n\n\t\tgame.Start(7)\n\n\t\tcases := []poker.ScheduledAlert{\n\t\t\t{At: 0 * time.Second, Amount: 100},\n\t\t\t{At: 12 * time.Minute, Amount: 200},\n\t\t\t{At: 24 * time.Minute, Amount: 300},\n\t\t\t{At: 36 * time.Minute, Amount: 400},\n\t\t}\n\n\t\tcheckSchedulingCases(cases, t, blindAlerter)\n\t})\n\n}\n\nfunc TestGame_Finish(t *testing.T) {\n\tstore := &poker.StubPlayerStore{}\n\tgame := poker.NewTexasHoldem(dummyBlindAlerter, store)\n\twinner := \"Ruth\"\n\n\tgame.Finish(winner)\n\tpoker.AssertPlayerWin(t, store, winner)\n}\n\nfunc checkSchedulingCases(cases []poker.ScheduledAlert, t *testing.T, blindAlerter *poker.SpyBlindAlerter) {\n\tfor i, want := range cases {\n\t\tt.Run(fmt.Sprint(want), func(t *testing.T) {\n\n\t\t\tif len(blindAlerter.Alerts) <= i {\n\t\t\t\tt.Fatalf(\"alert %d was not scheduled %v\", i, blindAlerter.Alerts)\n\t\t\t}\n\n\t\t\tgot := blindAlerter.Alerts[i]\n\t\t\tassertScheduledAlert(t, got, want)\n\t\t})\n\t}\n}",
  "difficulty": "Fácil"
}
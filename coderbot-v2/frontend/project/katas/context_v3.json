{
  "title": "V3",
  "content": "Store fetches data.",
  "correct_code": "package context3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// Store fetches data.\ntype Store interface {\n\tFetch(ctx context.Context) (string, error)\n}\n\n// Server returns a handler for calling Store.\nfunc Server(store Store) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tdata, err := store.Fetch(r.Context())\n\n\t\tif err != nil {\n\t\t\treturn // todo: log error however you like\n\t\t}\n\n\t\tfmt.Fprint(w, data)\n\t}\n}\n\npackage context3\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// SpyStore allows you to simulate a store and see how its used.\ntype SpyStore struct {\n\tresponse string\n}\n\n// Fetch returns response after a short delay.\nfunc (s *SpyStore) Fetch(ctx context.Context) (string, error) {\n\tdata := make(chan string, 1)\n\n\tgo func() {\n\t\tvar result string\n\t\tfor _, c := range s.response {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tlog.Println(\"spy store got cancelled\")\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\tresult += string(c)\n\t\t\t}\n\t\t}\n\t\tdata <- result\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn \"\", ctx.Err()\n\tcase res := <-data:\n\t\treturn res, nil\n\t}\n}\n\n// SpyResponseWriter checks whether a response has been written.\ntype SpyResponseWriter struct {\n\twritten bool\n}\n\n// Header will mark written to true.\nfunc (s *SpyResponseWriter) Header() http.Header {\n\ts.written = true\n\treturn nil\n}\n\n// Write will mark written to true.\nfunc (s *SpyResponseWriter) Write([]byte) (int, error) {\n\ts.written = true\n\treturn 0, errors.New(\"not implemented\")\n}\n\n// WriteHeader will mark written to true.\nfunc (s *SpyResponseWriter) WriteHeader(statusCode int) {\n\ts.written = true\n}",
  "test_code": "package context3\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestServer(t *testing.T) {\n\tdata := \"hello, world\"\n\n\tt.Run(\"returns data from store\", func(t *testing.T) {\n\t\tstore := &SpyStore{response: data}\n\t\tsvr := Server(store)\n\n\t\trequest := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t\tresponse := httptest.NewRecorder()\n\n\t\tsvr.ServeHTTP(response, request)\n\n\t\tif response.Body.String() != data {\n\t\t\tt.Errorf(`got \"%s\", want \"%s\"`, response.Body.String(), data)\n\t\t}\n\t})\n\n\tt.Run(\"tells store to cancel work if request is cancelled\", func(t *testing.T) {\n\t\tstore := &SpyStore{response: data}\n\t\tsvr := Server(store)\n\n\t\trequest := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\n\t\tcancellingCtx, cancel := context.WithCancel(request.Context())\n\t\ttime.AfterFunc(5*time.Millisecond, cancel)\n\t\trequest = request.WithContext(cancellingCtx)\n\n\t\tresponse := &SpyResponseWriter{}\n\n\t\tsvr.ServeHTTP(response, request)\n\n\t\tif response.written {\n\t\t\tt.Error(\"a response should not have been written\")\n\t\t}\n\t})\n}",
  "difficulty": "IntermediÃ¡rio"
}
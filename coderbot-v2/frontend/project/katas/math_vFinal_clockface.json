{
  "title": "Clockface",
  "content": "Package clockface provides functions that calculate the positions of the hands.",
  "correct_code": "// Package clockface provides functions that calculate the positions of the hands.\n// of an analogue clock,.\npackage clockface\n\nimport (\n\t\"math\"\n\t\"time\"\n)\n\nconst (\n\tsecondsInHalfClock = 30\n\tsecondsInClock     = 2 * secondsInHalfClock\n\tminutesInHalfClock = 30\n\tminutesInClock     = 2 * minutesInHalfClock\n\thoursInHalfClock   = 6\n\thoursInClock       = 2 * hoursInHalfClock\n)\n\n// A Point is a Cartesian coordinate. They are used in the package.\n// to represent the unit vector from the origin of a clock hand.\ntype Point struct {\n\tX float64\n\tY float64\n}\n\n// SecondsInRadians returns the angle of the second hand from 12 o'clock in radians.\nfunc SecondsInRadians(t time.Time) float64 {\n\treturn (math.Pi / (secondsInHalfClock / float64(t.Second())))\n}\n\n// SecondHandPoint is the unit vector of the second hand at time `t`,.\n// represented a Point.\nfunc SecondHandPoint(t time.Time) Point {\n\treturn angleToPoint(SecondsInRadians(t))\n}\n\n// MinutesInRadians returns the angle of the minute hand from 12 o'clock in radians.\nfunc MinutesInRadians(t time.Time) float64 {\n\treturn (SecondsInRadians(t) / minutesInClock) +\n\t\t(math.Pi / (minutesInHalfClock / float64(t.Minute())))\n}\n\n// MinuteHandPoint is the unit vector of the minute hand at time `t`,.\n// represented a Point.\nfunc MinuteHandPoint(t time.Time) Point {\n\treturn angleToPoint(MinutesInRadians(t))\n}\n\n// HoursInRadians returns the angle of the hour hand from 12 o'clock in radians.\nfunc HoursInRadians(t time.Time) float64 {\n\treturn (MinutesInRadians(t) / hoursInClock) +\n\t\t(math.Pi / (hoursInHalfClock / float64(t.Hour()%hoursInClock)))\n}\n\n// HourHandPoint is the unit vector of the hour hand at time `t`,.\n// represented a Point.\nfunc HourHandPoint(t time.Time) Point {\n\treturn angleToPoint(HoursInRadians(t))\n}\n\nfunc angleToPoint(angle float64) Point {\n\tx := math.Sin(angle)\n\ty := math.Cos(angle)\n\n\treturn Point{x, y}\n}",
  "test_code": "package clockface_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/quii/learn-go-with-tests/math/vFinal/clockface\"\n)\n\nfunc TestSecondsInRadians(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tangle float64\n\t}{\n\t\t{simpleTime(0, 0, 30), math.Pi},\n\t\t{simpleTime(0, 0, 0), 0},\n\t\t{simpleTime(0, 0, 45), (math.Pi / 2) * 3},\n\t\t{simpleTime(0, 0, 7), (math.Pi / 30) * 7},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := SecondsInRadians(c.time)\n\t\t\tif !roughlyEqualFloat64(got, c.angle) {\n\t\t\t\tt.Fatalf(\"Wanted %v radians, but got %v\", c.angle, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSecondHandPoint(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tpoint Point\n\t}{\n\t\t{simpleTime(0, 0, 30), Point{X: 0, Y: -1}},\n\t\t{simpleTime(0, 0, 45), Point{X: -1, Y: 0}},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := SecondHandPoint(c.time)\n\t\t\tif !roughlyEqualPoint(got, c.point) {\n\t\t\t\tt.Fatalf(\"Wanted %v Point, but got %v\", c.point, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMinutesInRadians(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tangle float64\n\t}{\n\t\t{simpleTime(0, 30, 0), math.Pi},\n\t\t{simpleTime(0, 0, 7), 7 * (math.Pi / (30 * 60))},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := MinutesInRadians(c.time)\n\t\t\tif !roughlyEqualFloat64(got, c.angle) {\n\t\t\t\tt.Fatalf(\"Wanted %v radians, but got %v\", c.angle, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMinuteHandPoint(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tpoint Point\n\t}{\n\t\t{simpleTime(0, 30, 0), Point{X: 0, Y: -1}},\n\t\t{simpleTime(0, 45, 0), Point{X: -1, Y: 0}},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := MinuteHandPoint(c.time)\n\t\t\tif !roughlyEqualPoint(got, c.point) {\n\t\t\t\tt.Fatalf(\"Wanted %v Point, but got %v\", c.point, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHoursInRadians(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tangle float64\n\t}{\n\t\t{simpleTime(6, 0, 0), math.Pi},\n\t\t{simpleTime(0, 0, 0), 0},\n\t\t{simpleTime(21, 0, 0), math.Pi * 1.5},\n\t\t{simpleTime(0, 1, 30), math.Pi / ((6 * 60 * 60) / 90)},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := HoursInRadians(c.time)\n\t\t\tif !roughlyEqualFloat64(got, c.angle) {\n\t\t\t\tt.Fatalf(\"Wanted %v radians, but got %v\", c.angle, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHourHandPoint(t *testing.T) {\n\tcases := []struct {\n\t\ttime  time.Time\n\t\tpoint Point\n\t}{\n\t\t{simpleTime(6, 0, 0), Point{X: 0, Y: -1}},\n\t\t{simpleTime(21, 0, 0), Point{X: -1, Y: 0}},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(testName(c.time), func(t *testing.T) {\n\t\t\tgot := HourHandPoint(c.time)\n\t\t\tif !roughlyEqualPoint(got, c.point) {\n\t\t\t\tt.Fatalf(\"Wanted %v Point, but got %v\", c.point, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc roughlyEqualFloat64(a, b float64) bool {\n\tconst equalityThreshold = 1e-7\n\treturn math.Abs(a-b) < equalityThreshold\n}\n\nfunc roughlyEqualPoint(a, b Point) bool {\n\treturn roughlyEqualFloat64(a.X, b.X) &&\n\t\troughlyEqualFloat64(a.Y, b.Y)\n}\n\nfunc simpleTime(hours, minutes, seconds int) time.Time {\n\treturn time.Date(312, time.October, 28, hours, minutes, seconds, 0, time.UTC)\n}\n\nfunc testName(t time.Time) string {\n\treturn t.Format(\"15:04:05\")\n}",
  "difficulty": "IntermediÃ¡rio"
}
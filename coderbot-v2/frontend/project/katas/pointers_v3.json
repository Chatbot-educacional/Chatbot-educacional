{
  "title": "V3",
  "content": "Bitcoin represents a number of Bitcoins.",
  "correct_code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Bitcoin represents a number of Bitcoins.\ntype Bitcoin int\n\nfunc (b Bitcoin) String() string {\n\treturn fmt.Sprintf(\"%d BTC\", b)\n}\n\n// Wallet stores the number of Bitcoin someone owns.\ntype Wallet struct {\n\tbalance Bitcoin\n}\n\n// Deposit will add some Bitcoin to a wallet.\nfunc (w *Wallet) Deposit(amount Bitcoin) {\n\tw.balance += amount\n}\n\n// Withdraw subtracts some Bitcoin from the wallet, returning an error if it cannot be performed.\nfunc (w *Wallet) Withdraw(amount Bitcoin) error {\n\n\tif amount > w.balance {\n\t\treturn errors.New(\"oh no\")\n\t}\n\n\tw.balance -= amount\n\treturn nil\n}\n\n// Balance returns the number of Bitcoin a wallet has.\nfunc (w *Wallet) Balance() Bitcoin {\n\treturn w.balance\n}",
  "test_code": "package main\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWallet(t *testing.T) {\n\n\tassertBalance := func(t testing.TB, wallet Wallet, want Bitcoin) {\n\t\tt.Helper()\n\t\tgot := wallet.Balance()\n\n\t\tif got != want {\n\t\t\tt.Errorf(\"got %s want %s\", got, want)\n\t\t}\n\t}\n\n\tassertError := func(t testing.TB, err error) {\n\t\tt.Helper()\n\t\tif err == nil {\n\t\t\tt.Error(\"wanted an error but didn't get one\")\n\t\t}\n\t}\n\n\tt.Run(\"deposit\", func(t *testing.T) {\n\t\twallet := Wallet{}\n\t\twallet.Deposit(Bitcoin(10))\n\n\t\tassertBalance(t, wallet, Bitcoin(10))\n\t})\n\n\tt.Run(\"withdraw with funds\", func(t *testing.T) {\n\t\twallet := Wallet{Bitcoin(20)}\n\t\twallet.Withdraw(Bitcoin(10))\n\n\t\tassertBalance(t, wallet, Bitcoin(10))\n\t})\n\n\tt.Run(\"withdraw insufficient funds\", func(t *testing.T) {\n\t\tstartingBalance := Bitcoin(20)\n\t\twallet := Wallet{startingBalance}\n\t\terr := wallet.Withdraw(Bitcoin(100))\n\n\t\tassertError(t, err)\n\t\tassertBalance(t, wallet, startingBalance)\n\t})\n}",
  "difficulty": "Intermedi√°rio"
}